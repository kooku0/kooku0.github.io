<!doctype html>
<html lang="ko" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-books/unit-testing/02" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">2. 단위 테스트란 무엇인가 | Kooku&#x27;s log</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://kooku0.github.io/docs/books/unit-testing/02/"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="2. 단위 테스트란 무엇인가 | Kooku&#x27;s log"><meta data-rh="true" name="description" content="- 단위 테스트란?"><meta data-rh="true" property="og:description" content="- 단위 테스트란?"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://kooku0.github.io/docs/books/unit-testing/02/"><link data-rh="true" rel="alternate" href="https://kooku0.github.io/docs/books/unit-testing/02/" hreflang="ko"><link data-rh="true" rel="alternate" href="https://kooku0.github.io/docs/books/unit-testing/02/" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"2. 단위 테스트란 무엇인가","item":"https://kooku0.github.io/docs/books/unit-testing/02"}]}</script><link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KVSM4B0KPY"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-KVSM4B0KPY",{})</script>



<link rel="alternate" type="application/rss+xml" href="/tech/rss.xml" title="Kooku&#39;s log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/tech/atom.xml" title="Kooku&#39;s log Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/fintech/rss.xml" title="Kooku&#39;s log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/fintech/atom.xml" title="Kooku&#39;s log Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/retrospect/rss.xml" title="Kooku&#39;s log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/retrospect/atom.xml" title="Kooku&#39;s log Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/journal/rss.xml" title="Kooku&#39;s log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/journal/atom.xml" title="Kooku&#39;s log Atom Feed"><link rel="stylesheet" href="/assets/css/styles.6d00d253.css">
<script src="/assets/js/runtime~main.5aceb8ad.js" defer="defer"></script>
<script src="/assets/js/main.f589d3d0.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/favicon.ico"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="사이드바 펼치거나 접기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.ico" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/favicon.ico" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Kooku&#x27;s log</b></a><a class="navbar__item navbar__link" href="/fintech/">핀테크</a><a class="navbar__item navbar__link" href="/tech/">테크</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/books/">Book</a><a class="navbar__item navbar__link" href="/journal/">Journal</a><a class="navbar__item navbar__link" href="/docs/smartfarm/">Smartfarm</a><a class="navbar__item navbar__link" href="/docs/stock/financial-statements/">Stock</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/kooku0/kooku0.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="맨 위로 스크롤하기" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="문서 사이드바" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/books/">책 목록</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/docs/books/clean-code/introduction/">테크</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docs/books/clean-code/introduction/">클린코드</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docs/books/object/introduction/">오브젝트</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docs/books/frameworkless-front-end-development/introduction/">프레임워크 없는 프론트엔드 개발</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/introduction/">만들면서 배우는 클린 아키텍처</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docs/books/functional-programming-in-scala/introduction/">스칼라로 배우는 함수형 프로그래밍</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docs/books/effective-typescript/introduction/">이펙티브 타입스크립트</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docs/books/the-pragmatic-programmer/introduction/">실용주의 프로그래머</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docs/books/test-driven-development/introduction/">테스트 주도 개발</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docs/books/functional-programming-in-javascript/introduction/">함수형 자바스크립트</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docs/books/designing-for-performance/introduction/">디자이너를 위한 웹 성능 최적화 기법</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docs/books/grokking-simplicity/introduction/">쏙쏙 들어오는 함수형 코딩</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" tabindex="0" href="/docs/books/unit-testing/introduction/">단위 테스트</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/unit-testing/introduction/">책 소개</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/unit-testing/01/">1. 단위 테스트의 목표</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/books/unit-testing/02/">2. 단위 테스트란 무엇인가</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/unit-testing/03/">3. 단위 테스트 구조</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/unit-testing/04/">4. 좋은 단위 테스트의 4대 요소</a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/books/atomic-habit/09/">자기계발</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/books/growth-hacking/01/">경영</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/books/around-industries-in-40-days/introduction/">핀테크</a></div></li></ul></nav><button type="button" title="사이드바 숨기기" aria-label="사이드바 숨기기" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="탐색 경로"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="홈" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">테크</span></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">단위 테스트</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">2. 단위 테스트란 무엇인가</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">이 페이지에서</button></div><div class="theme-doc-markdown markdown"><header><h1>2. 단위 테스트란 무엇인가</h1></header><div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>2장에서 다루는 내용</div><div class="admonitionContent_BuS1"><ul>
<li>단위 테스트란?</li>
<li>공유 의존성, 비공개 의존성, 휘발성 의존성 간의 차이점</li>
<li>단위 테스트의 두 분파: 고전파와 런던파</li>
<li>단위 테스트, 통합 테스트, 엔드 투 엔드 테스트의 차이점</li>
</ul></div></div>
<p>단위 테스트의 정의에는 많은 뉘앙스가 있다. 이런 뉘앙스는 생각보다 훨씬 중요하다. 해석의 차이가 생겼고, 단위 테스트에 접근하는 방법이 두 가지 뚜렸한 견해로 나뉘었다.</p>
<p>이러한 두 가지 견해는 각각 고전파(Classical school)와 런던파(London school)로 알려져 있다. 고전파는 모든 사람이 단위 테스트와 테스트 주도 개발에 원론적으로 접근하는 방식이기 때문에 &#x27;고전&#x27; 이라고 한다. 런던파는 런던의 프로그래밍 커뮤니티에서 시작됐다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="21-단위-테스트의-정의">2.1 &#x27;단위 테스트&#x27;의 정의<a href="#21-단위-테스트의-정의" class="hash-link" aria-label="2.1 &#x27;단위 테스트&#x27;의 정의에 대한 직접 링크" title="2.1 &#x27;단위 테스트&#x27;의 정의에 대한 직접 링크">​</a></h2>
<p>단위 테스트에는 가장 중요한 세 가지 속성이 있다.</p>
<ul>
<li>작은 코드 조각을 검증하고,</li>
<li>빠르게 수행하고</li>
<li>격리된 방식으로 처리하는 자동화된 테스트다.</li>
</ul>
<p>처음 두 속성은 논란의 여지가 없다. 대중의 의견이 크게 다른 것은 세 번째 속성이다. 격리 문제는 단위 테스트의 고전파와 런던파를 구분할 수 있게 해주는 근원적 차이에 속한다.</p>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>단위 테스트의 고전파와 런던파</div><div class="admonitionContent_BuS1"><p>고전적 접근법은 &#x27;디트로이트&#x27;라고도 하며, 때로는 단위 테스트에 대한 고전주의적 접근법이라고도 한다.</p><p>런던 스타일은 때때로 &#x27;목 추종자&#x27;로 표현된다. 목 추종자라는 용어가 널리 퍼져 있지만, 런던 스타일을 따르는 사람들은 보통 그렇게 부르는 것을 좋아하지 않는다.</p></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="211-격리-문제에-대한-런던파의-접근">2.1.1 격리 문제에 대한 런던파의 접근<a href="#211-격리-문제에-대한-런던파의-접근" class="hash-link" aria-label="2.1.1 격리 문제에 대한 런던파의 접근에 대한 직접 링크" title="2.1.1 격리 문제에 대한 런던파의 접근에 대한 직접 링크">​</a></h3>
<p>코드 조각을 격리된 방식으로 검증한다는 것은 무엇을 의미하는가? 런던파에서는 테스트 대상 시스템을 협력자에게서 격리하는 것을 일컫는다. 즉, 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체해야 한다. 이런 식으로 동작을 외부 영향과 분리해서 테스트 대상 클래스에만 집중할 수 있다.</p>
<p>의존성이 포함된 테스트 대상 시스템을 검증하는 단위 테스트는 해당 의존성과 별개로 수행할 수 있다.</p>
<p>이 방법의 한 가지 이점은 테스트가 실패하면 코드베이스의 어느 부분이 고장 났는지 확실히 알 수 있다는 것이다. 즉, 확실히 테스트 대상 시스템이 고장 난 것이다. 클래스의 모든 의존성은 테스트 대역으로 대체됐기 때문에 의심할 여지가 없다.</p>
<p>또 다른 이점은 객체 그래프를 분할할 수 있는 것이다. 모든 클래스가 각각 직접적인 의존성을 갖고 있으며 또 그 의존성이 또 다른 의존성을 갖고 있는 식으로, 그래프가 상당히 복잡해질 수 있다. 클래스는 심지어 순환 의존성이 있을 수도 있는데, 이는 의존성 사슬이 결국 시작된 위치로 돌아오는 것이다.</p>
<p>의존성을 가진 코드베이스를 테스트하는 것은 테스트 대역 없이는 어렵다. 유일하게 남은 선택은 전체 객체 그래프를 다시 만드는 것이다. 하지만 클래스의 수가 너무 많으면 어려운 작업일 수 있다.</p>
<p>테스트 대역을 사용하면 객체 그래프를 다시 만들지 않아도 된다. 또한 클래스의 직접적인 의존성을 대체할 수 있고, 더 나아가 의존성의 의존성을 다룰 필요도 없다. 그래프를 효과적으로 분해해 단위 테스트에서 준비를 크게 줄일 수 있다.</p>
<p>또한 단위 테스트 격리에는 작지만 유익한 부가적인 이점이 더 있다. 프로젝트 전반적으로 한 번에 한 클래스만 테스트하라는 지침을 도입하면 전체 단위 테스트 스위트를 간단한 구조로 할 수 있다. 더 이상 코드베이스를 테스트하는 방법을 고민할 필요가 없다.</p>
<p>몇 가지 예를 살펴보자. 고전적인 스타일이 대부분의 사람들에게 더 익숙하기 때문에 먼저 고전적인 스타일로 작성된 샘플 테스트를 살펴본 후 런던 방식을 사용해 다시 작성해 볼 것이다.</p>
<p>온라인 상점을 운영한다고 가정하자. 샘플 애플리케이션에는 고객에 제품을 구매할 수 있다는 간단한 유스케이스가 하나 있다. 상점에 재고가 충분하면 구매는 성공으로 간주되고, 구매 수량만큼 상점의 제품 수량이 줄어든다. 제품이 충분하지 않으면 구매는 성공하지 못하며 상점에 아무 일도 일어나지 않는다.</p>
<p>예제 2.1에는 상점에 재고가 충분히 있을 때만 구매가 성공하는지 검증하는 두 가지 테스트가 있다.</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockTitle_OeMC">예제 2.1 고전적인 스타일로 작성된 테스트</div><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// [Fact]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void Purchase_succeeds_when_enough_inventory()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 준비</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var store = new Store();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  store.AddInventory(Product.Shampoo, 10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var customer = new Customer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 실행</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bool success = customer.Purchase(store, Product.Shampoo, 5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 검증</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Assert.True(success);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Assert.Equal(5, store.GetInventory(Product.Shampoo)); // 상점 제품 다섯 개 감소</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// [Fact]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void Purchase_fails_when_not_enough_inventory()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 준비</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var store = new Store();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  store.AddInventory(Product.Shampoo, 10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var customer = new Customer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 실행</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bool success = customer.Purchase(store, Product.Shampoo, 15);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 검증</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Assert.True(success);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Assert.Equal(10, store.GetInventory(Product.Shampoo)); // 상점 제품 수량 변화 없음</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public enum Product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Shampoo,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Book</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>준비 단계에서는 테스트 대상 시스템(SUT, system under test)과 하나의 협력자를 준비한다. 이 경우 고객이 SUT에, 상점이 협력자에 해당한다. 다음 두 가지 이유로 협력자가 필요하다.</p>
<ul>
<li>테스트 대상 메서드를 컴파일 하려면 customer.Purchase()가 Store 인스턴스를 인수로 필요로 하기 때문에</li>
<li>검증 단계에서 customer.Purchase()의 결과 중 하나로 상점 제품 수량이 감소할 가능성이 있기 때문에</li>
</ul>
<p>이 코드는 단위 테스트의 고전 스타일 예로, 테스트는 협력자를 대체하지않고 운영용 인스턴스를 사용한다. 고전적인 방식의 자연스로운 결과로, 이제 Customer만이 아니라 Customer와 Store 둘 다 효과적으로 검증한다. 그러나 Customer가 올바르게 작동하더라도 Customer에 영향을 미치는 Store 내부에 버그가 있으면 단위 테스트에 실패할 수 있다. 테스트에서 두 클래스는 서로 격리돼 있지 않다.</p>
<p>이제 런던 스타일로 예제를 수정해보자. 동일한 테스트에서 Store 인스턴스는 테스트 대역, 구체적으로 목으로 교체해본다.</p>
<p>사람들이 흔히 테스트 대역과 목을 동의어로 사용하지만, 기술적으로는 그렇지 않다. (목이 테스트 대역의 부분집합이다.)</p>
<ul>
<li>테스트 대역은 실행과 관련 없이 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어다.</li>
<li>목은 그러한 의존성의 한 종류일 뿐이다.</li>
</ul>
<p>다음 예제에서는 Customer가 협력자인 Store에서 격리된 후 어떻게 테스트가 수행되는지 보여준다.</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockTitle_OeMC">예제 2.2 런던 스타일로 작성된 단위 테스트</div><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// [Fact]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void Purchase_succeeds_when_enough_inventory()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 준비</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var storeMock = new Mock&lt;IStore&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  storeMock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .Setup(x =&gt; x.HasEnoughInventory(Product.Shampoo, 5))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .Returns(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var customer = new Customer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 실행</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bool success = customer.Purchase(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    storeMock.Object, Product.Shampoo, 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 검증</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Assert.True(success);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Assert.Verify(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x =&gt; x.RemoveInventory(Product.Shampoo, 5),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Times.Once</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// [Fact]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void Purchase_fails_when_not_enough_inventory()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 준비</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var storeMock = new Mock&lt;IStore&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  storeMock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .Setup(x =&gt; x.HasEnoughInventory(Product.Shampoo, 5))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .Returns(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var customer = new Customer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 실행</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bool success = customer.Purchase(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    storeMock.Object, Product.Shampoo, 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 검증</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Assert.False(success);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Assert.Verify(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x =&gt; x.RemoveInventory(Product.Shampoo, 5),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Times.Never</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ); // 상점 제품 수량 변화 없음</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public enum Product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Shampoo,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Book</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>고전 스타일로 작성된 테스트와 얼마나 다른지 살펴보자. 준비 단계에서 테스트는 Store의 실제 인스턴스를 생성하지 않고 Moq의 내장 클래스인 Mock&lt;T&gt;를 사용해 대체한다.</p>
<p>검증 단계도 바뀌었고 중요한 차이점이 여기에 있다. 여전히 이전과 같이 customer.Purchase 호출 결과를 확인하지만, 고객이 상점에서 올바르게 했는지 확인하는 방법이 다르다. 이전에는 상점 상태를 검증했다. 지금은 Customer와 Store 간의 상호 작용을 검사한다. 즉, 고객이 상점에서 호출을 올바르게 했는지 확인한다. 고객이 상점으로 호출해야 하는 메서드뿐만 아니라 호출 횟수까지 검증할 수 있다. 고객은 구매가 성공하면 이 메서드를 한 번만 호출해야 하고, 구매가 실패하면 절대로 호출하면 안 된다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="212-격리-문제에-대한-고전파의-접근">2.1.2. 격리 문제에 대한 고전파의 접근<a href="#212-격리-문제에-대한-고전파의-접근" class="hash-link" aria-label="2.1.2. 격리 문제에 대한 고전파의 접근에 대한 직접 링크" title="2.1.2. 격리 문제에 대한 고전파의 접근에 대한 직접 링크">​</a></h3>
<p>다시 말하면, 런던 스타일은 테스트 대역으로 테스트 대상 코드 조각을 분리해서 격리 요구 사항에 다가간다. 흥미롭게도 이 관점은 무엇이 작은 코드 조각에 해당하는지에 대한 견해에도 영향을 미친다.</p>
<p>각각의 모든 클래스를 격리해야 한다면 테스트 대상 코드 조각은 당연히 단일 클래스이거나 해당 클래스 내의 메서드여야 한다. 격리 문제에 접근하는 방식 때문에 이보다 더 클 수가 없다. 때에 따라 한 번에 몇 개의 클래스를 테스트하는 지침을 따르려고 노력해야 한다.</p>
<p>앞에서 언급했듯이 격리 특성을 해석하는 또 다른 방법으로 고전적인 방법이 있다. 고전적인 방법에서 코드를 꼭 격리하는 방식으로 테스트해야 하는 것이 아니다. 대신 단위 테스트는 서로 격리해서 실행해야 한다. 이렇게 하면 테스트를 어떤 순서로든 가장 적합한 방식으로 실행할 수 있으며 서로의 결과에 영향을 미치지 않는다.</p>
<p>각각의 테스트를 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 한, 여러 클래스를 한 번에 테스트해도 괜찮다는 뜻이다. 이를 통해 테스트가 서로 소통하고 실행 컨텍스트에 영향을 줄 수 있다. 데이터베이스, 파일 시스템 등 프로세스 외부 의존성이 이러한 공유 상태의 대표적인 예다.</p>
<p>예를 들어 어떤 테스트가 준비 단계에서 데이터베이스에서 고객을 생성할 수 있고, 이 테스트가 실행되기 전에 다른 테스트의 준비 단계에서 고객을 삭제할 수도 있다. 이 두 가지 테스트를 병렬로 실행하면 첫 번째 테스트가 실패하는데, 이는 제품 코드가 고장 나서가 아니라 두 번째 테스트의 간섭 때문이다.</p>
<p>격리 문제에 대한 이러한 견해는 목과 기타 테스트 대역의 사용에 대한 훨씬 더 평범한 견해를 수반한다. 테스트 대역을 사용할 수 있지만, 보통 테스트 간에 공유 상태를 일으키는 의존성에 대해서만 사용한다.</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/2.3-e59d497455f8f9a626d4795e71551107.png" width="1572" height="1248" class="img_ev3q"></p>
<p>공유 의존성은 테스트 대상 클래스 간이 아니라 단위 테스트 간에 공유한다. 그런 의미에서 싱글턴 의존성은 각 테스트에서 새 인스턴스를 만들 수 있기만 하면 공유되지 않는다. 제품 코드에는 싱글턴 인스턴스가 단 하나만 있지만, 테스트는 이 패턴을 따르지 않고 재사용하지도 않는다. 따라서 이러한 의존성은 비공개인 것이다.</p>
<p>새 파일 시스템이나 데이터베이스를 만들 수는 없으며, 테스트 간에 공유되거나 테스트 대역으로 대치돼야 한다.</p>
<p>공유 의존성을 대체하는 또 다른 이유는 테스트 실행 속도를 높이는 데 있다. 공유 의존성은 거의 항상 실행 프로세스 외부에 있는 데 반해, 비공개 의존성은 보통 그 경계를 넘지 않는다. 따라서 데이터베이스나 파일 시스템 등의 공유 의존성에 대한 호출은 비공개 의존성에 대한 호출보다 더 오래 간다. 그리고 단위 테스트 두 번째 속성으로 빨리 실행해야하는 필요성이 있으므로, 이러한 호출을 포함하는 공유 의존성을 가진 테스트는 단위 테스트 영역에서 통합 테스트 영역으로 넘어간다.</p>
<p>공유 의존성이 없는 한 여러 클래스를 묶어 단위 테스트할 수도 있다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="22-단위-테스트의-런던파와-고전파">2.2. 단위 테스트의 런던파와 고전파<a href="#22-단위-테스트의-런던파와-고전파" class="hash-link" aria-label="2.2. 단위 테스트의 런던파와 고전파에 대한 직접 링크" title="2.2. 단위 테스트의 런던파와 고전파에 대한 직접 링크">​</a></h2>
<p>런던파와 고전파로 나눠진 원인은 격리 특성에 있다. 런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 보는 반면, 고전파는 단위 테스트끼리 격리하는 것으로 본다.</p>
<p>세 가지 주제에 대해 의견 차이가 있다.</p>
<ul>
<li>격리 요구 사항</li>
<li>테스트 대상 코드 조각의 구성 요소</li>
<li>의존성 처리</li>
</ul>
<table><thead><tr><th></th><th>격리 주체</th><th>단위의 크기</th><th>테스트 대역 사용 대상</th></tr></thead><tbody><tr><td>런던파</td><td>단위</td><td>단일 클래스</td><td>불변 의존성 외 모든 의존성</td></tr><tr><td>고전파</td><td>단위 테스트</td><td>단일 클래스 또는 클래스 세트</td><td>공유 의존성</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="221-고전파와-런던파가-의존성을-다루는-방법">2.2.1. 고전파와 런던파가 의존성을 다루는 방법<a href="#221-고전파와-런던파가-의존성을-다루는-방법" class="hash-link" aria-label="2.2.1. 고전파와 런던파가 의존성을 다루는 방법에 대한 직접 링크" title="2.2.1. 고전파와 런던파가 의존성을 다루는 방법에 대한 직접 링크">​</a></h3>
<p>테스트 대역을 어디에서나 흔히 사용할 수 있지만, 런던파는 테스트에서 일부 의존성을 그대로 사용할 수 있도록 하고 있다. 절대 변하지 않는 객체, 즉 불변 객체는 교체하지 않아도 된다.</p>
<p>이전 예제에서 봤듯이, 테스트를 런던 스타일로 리팩터링하면 Product 인스턴스를 목으로 바꾸지 않고 실제 객체를 사용한다. Customer의 두 가지 의존성 중 Store만 시간에 따라 변할 수 있는 내부 상태를 포함하고 있다. Product 인스턴스는 불변이다. 따라서 Store 인스턴스만 교체했다.</p>
<p>이러한 불변 객체를 값 객체 또는 값이라고 한다. 주요 특징은 각각의 정체성이 없다는 것이다. 즉, 내용에 의해서만 식별된다. 그 결과, 두 객체가 동일한 내용을 갖고 있다면 어떤 객체를 사용하든 상관없다.</p>
<p>비공개 의존성은 변경 가능하거나 불변일 수 있다. 불변인 경우 값객체라고 부른다. 예를 들어 데이터베이스는 공유 의존성이며, 내부 상태는 모든 자동화된 테스트에서 공유한다. Store 인스턴스는 변경 가능한 비공개 의존성이다. 그리고 Product 인스턴스는 불변인 비공개 의존성. 즉 값 객체의 예다. 모든 공유 의존성은 변경 가능하지만, 변경 가능한 의존성을 공유하려면 여러 테스트에서 재사용돼야 한다.</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/2.4-49458b64333d4d8f7dfd7619338a7566.png" width="1790" height="1212" class="img_ev3q"></p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>협력자 대 의존성</div><div class="admonitionContent_BuS1"><p>협력자(collaborator)는 공유하거나 변경 가능한 의존성이다. 예를 들어, 데이터베이스는 공유 의존성이므로 데이터베이스 접근 권한을 제공하는 클래스는 협럭자다. Store도 시간에 따라 상태가 변할 수 있기 때문에 협럭자다.</p><p>Product와 숫자 5도 역시 의존성이지만 협력자는 아니다. 값 또는 값 객체로 분류된다.</p><p>일반적인 클래스는 두 가지 유형의 의존성으로 동작한다. 협력자와 값이다.</p></div></div>
<p>모든 프로세스 외부 의존성이 공유 의존성의 범주에 속하는 것은 아니다. 공유 의존성은 거의 항상 프로세스 외부에 있지만, 그 반대는 그렇지 않다. 프로세스 외부 의존성을 공유하려면 단위 테스트가 서로 통신할 수 있는 수단이 있어야 한다. 의존성 내부 상태를 수정하면 통신이 이뤄진다. 그런 의미에서 프로세스 외부의 불변 의존성은 그런 수단을 제공하지 않는다. 테스트는 내부의 어떤 것도 수정할 수 없기 때문에 서로 실행 컨텍스트에 영향을 줄 수 없다.</p>
<p>예를 들어 조직에서 판매하는 모든 제품에 대한 카탈로그를 반환하는 API가 있다면, API는 카탈로그를 변경하는 기능을 노출하지 않는 한 공유 의존성이 아니다. 이러한 의존성은 휘발성이고 애플리케이션 경계를 벗어나는 것이 사실이지만, 테스트가 반환하는 데이터에 영향을 미칠 수 없기 때문에 공유가 아니다. 대부분의 경우 테스트 속도를 높이려면 테스트 대역으로 교체해야 한다. 그러나 프로세스 외부 의존성이 충분히 빠르고 연결이 안정적이면 테스트에서 그대로 사용하는 것도 괜찮다.</p>
<p>실제 프로젝트에서 프로세스 외부가 아닌 공유 의존성은 거의 없다. 의존성이 프로세스 내부에 있으면 각 테스트에서 별도의 인스턴스를 쉽게 공급할 수 있으므로 테스트 간에 공유할 필요가 없다. 마찬가지로 공유되지 않는 프로세스 외부 의존성은 일반적으로 접할 일이 없다. 이러한 의존성 대부분은 변경 가능하며 테스트로 수정될 수 있다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="23-고전파와-런던파-비교">2.3. 고전파와 런던파 비교<a href="#23-고전파와-런던파-비교" class="hash-link" aria-label="2.3. 고전파와 런던파 비교에 대한 직접 링크" title="2.3. 고전파와 런던파 비교에 대한 직접 링크">​</a></h2>
<p>고전파와 런던파 간의 주요 차이는 단위 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있다.</p>
<p>개인적으로 단위 테스트 고전파를 선호한다. 이는 고품질의 테스트를 만들고 단위 테스트의 궁극적인 목표인 프로젝트의 지속 가능한 성장을 달성하는 데 더 적합하다. 그 이유는 취약성에 있다. 목을 사용하는 테스트는 고전적인 테스트보다 불안정한 경향이 있기 때문이다.</p>
<p>런던파의 접근 방식은 다음과 같은 이점을 제공한다.</p>
<ul>
<li>입자성이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인한다.</li>
<li>서로 연결된 클래스의 그래프가 켜져도 테스트하기 쉽다. 모든 협력자는 테스트 대역으로 대체되기 때문에 테스트 작성 시 걱정할 필요가 없다.</li>
<li>테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다. 클래스의 협력자가 없으면 테스트 대상 클래스 외에 다른 것을 의심할 여지가 없다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="231-한-번에-한-클래스만-테스트하기">2.3.1. 한 번에 한 클래스만 테스트하기<a href="#231-한-번에-한-클래스만-테스트하기" class="hash-link" aria-label="2.3.1. 한 번에 한 클래스만 테스트하기에 대한 직접 링크" title="2.3.1. 한 번에 한 클래스만 테스트하기에 대한 직접 링크">​</a></h3>
<p>런던파는 클래스를 단위로 간주한다. 클래스를 테스트에서 검증할 원자 단위로도 취급하게 한다. 이런 경향은 이해되기는 하지만 오해의 소지가 있다. 그래서 좋은 코드 입자성을 목표로 하는 것은 도움이 되지 않는다. 테스트가 단일 동작 단위를 검증하는 한 좋은 테스트다. 이보다 적은 것을 목표로 삼는다면 사실 단위 테스트를 훼손하는 결과를 가져온다. 이 테스트가 무엇을 검증하는지 정확히 이해하기가 더 어려워지기 때문이다.</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>팁</div><div class="admonitionContent_BuS1"><p>테스트는 코드의 단위를 검증해서는 안 된다. 오히려 동작의 단위, 즉 문제 영역에 의미가 있는 것. 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다. 동작 단위를 구현하는 데 클래스가 얼마나 필요한지는 상관없다. 단위는 여러 클래스에 걸쳐 있거나 한 클래스에만 있을 수 있고, 심지어 아주 작은 메서드가 될 수도 있다.</p></div></div>
<p>테스트는 해결하는 데 도움이 되는 문제에 대한 이야기를 들려줘야 하며, 이 이야기는 프로그래머가 아닌 일반 사람들에게 응집도가 높고 의미가 있어야 한다.
예를 들어 다음은 응집도가 높은 이야기의 예다.</p>
<blockquote>
<p>우리집 강아지를 부르면, 바로 나에게 온다.</p>
</blockquote>
<p>이제 다음과 비교해보자.</p>
<blockquote>
<p>우리집 강아지를 부르면 먼저 왼쪽 앞다리를 움직이고, 이어서 오른쪽 앞다리를 움직이고, 머리를 돌리고, 꼬리를 흔들기 시작한다.</p>
</blockquote>
<p>두 번째 이야기는 훨씬 말이 안된다. 저 움직임은 모두 무엇인가? 강아지가 나에게 오고 있는가? 아니면 도망을 가고 있는가? 실제 동작 대신 개별 클래스를 목표로 할 때 테스트가 이렇게 보이기 시작한다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="232-상호-연결된-클래스의-큰-그래프를-단위-테스트하기">2.3.2. 상호 연결된 클래스의 큰 그래프를 단위 테스트하기<a href="#232-상호-연결된-클래스의-큰-그래프를-단위-테스트하기" class="hash-link" aria-label="2.3.2. 상호 연결된 클래스의 큰 그래프를 단위 테스트하기에 대한 직접 링크" title="2.3.2. 상호 연결된 클래스의 큰 그래프를 단위 테스트하기에 대한 직접 링크">​</a></h3>
<p>실제 협력자를 대신해 목을 사용하면 클래스를 쉽게 테스트할 수 있다. 특히 테스트 대상 클래스에 의존성이 있고, 이 의존성에 다시 각각의 의존성이 있고, 이렇게 여러 계층에 걸쳐서 계속되는 식으로 의존성 그래프가 복잡하게 있을 때 쉽게 테스트할 수 있다. 테스트 대역을 쓰면 클래스의 직접적인 의존성을 대체해 그래프를 나눌 수 있으며, 이는 단위 테스트에서 준비해야 할 작업량을 크게 줄일 수 있다. 고전파를 따라 테스트 대상 시스템을 설정하려면 전체 객체 그래프를 다시 생성해야 하는데, 작업이 많을 수 있다.</p>
<p>모두 사실이지만, 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다. 대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과다.</p>
<p>테스트에서 이 문제를 지적한 것은 사실 좋은 일이다. 비교적 높은 정확도로 저품질을 예측한다. 클래스를 단위 테스트하려면 테스트 준비 단계를 적정선을 넘게 늘려야 해서 이는 틀림없이 문제의 징후가 있다. 목을 사용하는 것은 이 문제를 감추기만 할 뿐, 원인을 해결하지 못한다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="233-버그-위치-정확히-찾아내기">2.3.3. 버그 위치 정확히 찾아내기<a href="#233-버그-위치-정확히-찾아내기" class="hash-link" aria-label="2.3.3. 버그 위치 정확히 찾아내기에 대한 직접 링크" title="2.3.3. 버그 위치 정확히 찾아내기에 대한 직접 링크">​</a></h3>
<p>런던 스타일 테스트가 있는 시스템에 버그가 생기면, 보통 sut에 버그가 포함된 테스트만 실패한다. 하지만 고전적인 방식이면, 오작동하는 클래스를 참조하는 클라이언트를 대상으로 하는 테스트도 실패할 수 있다. 즉, 하나의 버그가 전체 시스템에 걸쳐 테스트 실패를 야기하는 파급 효과를 초래한다. 결국 문제의 원인을 찾기가 더 어려워진다. 문제를 파악하고자 테스트를 디버깅하는 데 시간이 걸릴 수 있다.</p>
<p>우려할 만하지만, 큰 문제는 아니다. 테스트를 정기적으로 실행하면 버그의 원인을 알아낼 수 있다. 즉, 마지막으로 한 수정이 무엇인지 알기 때문에 문제를 찾는 것은 그리 어렵지 않다. 또한 실패한 테스트를 모두 볼 필요는 없다. 하나를 고치면 다른 것들도 자동으로 고쳐진다.</p>
<p>테스트 스위트 전체에 걸쳐 계단식으로 실패하는 데 가치가 있다. 버그가 테스트 하나뿐만 아니라 많은 테스트에서 결함으로 이어진다면, 방금 고장 낸 코드 조각이 큰 가치가 있다는 것을 보여준다. 즉, 전체 시스템이 그것에 의존한다. 유요한 정보다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="234-고전파와-런던파-사이의-다른-차이점">2.3.4. 고전파와 런던파 사이의 다른 차이점<a href="#234-고전파와-런던파-사이의-다른-차이점" class="hash-link" aria-label="2.3.4. 고전파와 런던파 사이의 다른 차이점에 대한 직접 링크" title="2.3.4. 고전파와 런던파 사이의 다른 차이점에 대한 직접 링크">​</a></h3>
<p>고전파와 런던파 사이에 남아있는 두 가지 차이점은 다음과 같다.</p>
<ul>
<li>테스트 주도 개발을 통한 시스템 설계 방식</li>
<li>과도한 명세 문제</li>
</ul>
<p>런던 스타일의 단위 테스트는 하향식 TDD로 이어지며, 전체 시스템에 대한 기대를 설정하는 상위 레벨 테스트부터 시작한다. 목을 사용해 예상 결과를 달성하고자 시스템이 통신해야 하는 협력자를 지정한다. 그런 다음 모든 클래스를 구현할 때까지 클래스 그래프를 다져나간다. 목은 한 번에 한 클래스에 집중할 수 있기 때문에 이 설계 프로세스를 가능하게 한다.</p>
<p>고전파는 테스트에서 실제 객체를 다뤄야 하기 때문에 지침을 똑같이 두지 않는다. 대신 일반적으로 상향식으로 한다. 고전적 스타일에서는 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 그 위에 더 둔다.</p>
<p>런던 스타일은 고전 스타일보다 테스트가 구현에 더 자주 결합되는 편이다. 이로 인해 런던 스타일과 목을 전반적으로 아무 데나 쓰는 것에 대해 주로 이의가 제기된다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="24-두-분파의-통합-테스트">2.4. 두 분파의 통합 테스트<a href="#24-두-분파의-통합-테스트" class="hash-link" aria-label="2.4. 두 분파의 통합 테스트에 대한 직접 링크" title="2.4. 두 분파의 통합 테스트에 대한 직접 링크">​</a></h2>
<p>런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다. 고전 스타일로 작성된 대부분의 테스트는 런던파 지지자들에게 통합 테스트로 느껴질 것이다.</p>
<p>단위 테스트는 다음과 같은 특징이 있는 자동화된 테스트다.</p>
<ul>
<li>작은 코드 조각을 검증하고</li>
<li>빠르게 수행하고</li>
<li>격리된 방식으로 처리한다.</li>
</ul>
<p>고전파 관점에서 다시 정의한 단위 테스트는</p>
<ul>
<li>단일 동작 단위를 검증하고</li>
<li>빠르게 수행하고</li>
<li>다른 테스트와 별도로 처리한다.</li>
</ul>
<p>통합 테스트는 이러한 기준 중 하나를 충족하지 않는 테스트다. 예를 들어 공유 의존성에 접근하는 테스트는 다른 테스트와 분리해 실행할 수 없다.</p>
<p>둘 이상의 동작 단위를 검증할 때의 테스트는 통합 테스트다. 이는 종종 테스트 스위트의 실행 속도를 최적화하려는 노력의 결과다. 비슷한 단계를 따르지만 다른 동작 단위를 검증하는 느린 테스트가 두 개 있을 때, 하나로 합치는 것이 타당할 수 있다.</p>
<p>또한 다른 팀이 개발한 모듈이 둘 이상 있을 때 통합 테스트로 어떻게 작동하는지 검증할 수 있다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="241-통합-테스트의-일부인-엔드-투-엔드-테스트">2.4.1. 통합 테스트의 일부인 엔드 투 엔드 테스트<a href="#241-통합-테스트의-일부인-엔드-투-엔드-테스트" class="hash-link" aria-label="2.4.1. 통합 테스트의 일부인 엔드 투 엔드 테스트에 대한 직접 링크" title="2.4.1. 통합 테스트의 일부인 엔드 투 엔드 테스트에 대한 직접 링크">​</a></h3>
<p>간단히 말해 통합 테스트는 공유 의존성, 프로세스 외부 의존성뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트다. 엔드 투 엔드 테스트라는 개념도 따로 있다. e2e는 통합 테스트의 일부다. e2e 테스트도 코드가 프로세스 외부 종속성과 함께 어떻게 작동하는지 검증한다. e2e 테스트와 통합 테스트 간의 차이점은 e2e가 일반적으로 의존성을 더 많이 포함한다는 것이다.</p>
<p>가끔 경계가 흐리지만, 일반적으로 통합 테스트는 프로세스 외부 의존성을 한두 개만 갖고 작동한다. 반면에 e2e 테스트는 프로세스 외부 의존성을 전부 또는 대다수 갖고 작동한다. 따라서 e2e는 모든 외부 애플리케이션을 포함해 시스템을 최종 사용자의 관점에서 검증하는 것을 의미한다.</p>
<p>e2e 테스트는 유지 보수 측면에서 가장 비용이 많이 들기 때문에 모든 단위 테스트와 통합 테스트를 통과한 후 빌드 프로세스 후반에 실행하는 것이 좋다.</p>
<p>e2e 테스트도 테스트 대역을 사용할 수도 있고 통합 테스트와 뚜렸한 경계가 없다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="요약">요약<a href="#요약" class="hash-link" aria-label="요약에 대한 직접 링크" title="요약에 대한 직접 링크">​</a></h2>
<ul>
<li>단위 테스트의 정의<!-- -->
<ul>
<li>단일 동작 단위를 검증하고</li>
<li>빠르게 수행하고</li>
<li>다른 테스트와 별도로 처리한다.</li>
</ul>
</li>
<li>고전파와 런던파는 무엇이 단위를 의미하는지에 대한 관점과 테스트 대상 시스템의 의존성 처리 방식이 다르다.<!-- -->
<ul>
<li>런던파는 테스트 대상 단위를 서로 분리해야 한다고 한다. 테스트 대상 단위는 코드의 단위, 보통 단일 클래스다. 불변 의존성을 제외한 모든 의존성을 테스트 대역으로 대체해야 한다.</li>
<li>고전파는 단위가 아니라 단위 테스트를 서로 분리해야 한다고 한다. 또한 테스트 대상 단위는 코드 단위가 아니라 동작 단위다. 따라서 공유 의존성만 테스트 대역으로 대체해야 한다. 공유 의존성은 테스트가 서로 실행 흐름에 영향을 미치는 수단을 제공하는 의존성이다.</li>
</ul>
</li>
<li>런던파는 더 나은 입자성의 이점, 상호 연결된 클래스의 큰 그래프에 대한 테스트 용이성 그리고 테스트 실패 후 버그가 있는 기능을 쉽게 찾을 수 있는 편의성 등을 제공한다.</li>
<li>런던파의 장점이 처음에는 매력적으로 보인다. 그러나 몇 가지 문제가 있다. 테스트는 코드 단위가 아니라 동작 단위를 검증해야 한다. 코드 조각을 단위 테스트할 수 없다는 것은 코드 설계에 문제가 있다는 사실을 알려주는 강한 징후다. 테스트 대역을 사용한다고 해도 이 문제를 해결하는 게 아니라 오히려 숨길 뿐이다. 마지막으로 테스트 실패 후 어떤 기능에 버그가 있는지 판단하는 것이 도움은 되지만, 종종 버그의 원인을 알고 있기 때문에 그리 큰 문제는 아니다. 마지막에 수정한 것이 버그의 원인이다.</li>
<li>런던파 테스트의 가장 큰 문제는 과잉 명세, 세부 구현에 결합된 테스트 문제다.</li>
<li>통합 테스트는 단위 테스트 기준 중 하나 이상을 충족하지 못하는 테스트다. e2e 테스트는 통합 테스트의 일부다. 최종 사용자의 관점에서 시스템을 검증한다. e2e 테스트는 애플리케이션과 함께 작동하는 프로세스 외부 의존성의 전부 또는 대부분에 직접 접근한다.</li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/kooku0/kooku0.github.io/edit/main/docs/books/unit-testing/02.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>페이지 편집</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="문서 페이지"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/books/unit-testing/01/"><div class="pagination-nav__sublabel">이전</div><div class="pagination-nav__label">1. 단위 테스트의 목표</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/books/unit-testing/03/"><div class="pagination-nav__sublabel">다음</div><div class="pagination-nav__label">3. 단위 테스트 구조</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#21-단위-테스트의-정의" class="table-of-contents__link toc-highlight">2.1 &#39;단위 테스트&#39;의 정의</a><ul><li><a href="#211-격리-문제에-대한-런던파의-접근" class="table-of-contents__link toc-highlight">2.1.1 격리 문제에 대한 런던파의 접근</a></li><li><a href="#212-격리-문제에-대한-고전파의-접근" class="table-of-contents__link toc-highlight">2.1.2. 격리 문제에 대한 고전파의 접근</a></li></ul></li><li><a href="#22-단위-테스트의-런던파와-고전파" class="table-of-contents__link toc-highlight">2.2. 단위 테스트의 런던파와 고전파</a><ul><li><a href="#221-고전파와-런던파가-의존성을-다루는-방법" class="table-of-contents__link toc-highlight">2.2.1. 고전파와 런던파가 의존성을 다루는 방법</a></li></ul></li><li><a href="#23-고전파와-런던파-비교" class="table-of-contents__link toc-highlight">2.3. 고전파와 런던파 비교</a><ul><li><a href="#231-한-번에-한-클래스만-테스트하기" class="table-of-contents__link toc-highlight">2.3.1. 한 번에 한 클래스만 테스트하기</a></li><li><a href="#232-상호-연결된-클래스의-큰-그래프를-단위-테스트하기" class="table-of-contents__link toc-highlight">2.3.2. 상호 연결된 클래스의 큰 그래프를 단위 테스트하기</a></li><li><a href="#233-버그-위치-정확히-찾아내기" class="table-of-contents__link toc-highlight">2.3.3. 버그 위치 정확히 찾아내기</a></li><li><a href="#234-고전파와-런던파-사이의-다른-차이점" class="table-of-contents__link toc-highlight">2.3.4. 고전파와 런던파 사이의 다른 차이점</a></li></ul></li><li><a href="#24-두-분파의-통합-테스트" class="table-of-contents__link toc-highlight">2.4. 두 분파의 통합 테스트</a><ul><li><a href="#241-통합-테스트의-일부인-엔드-투-엔드-테스트" class="table-of-contents__link toc-highlight">2.4.1. 통합 테스트의 일부인 엔드 투 엔드 테스트</a></li></ul></li><li><a href="#요약" class="table-of-contents__link toc-highlight">요약</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/tech/">테크</a></li><li class="footer__item"><a class="footer__link-item" href="/fintech/">핀테크</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/books/">책</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/kooku0/kooku0.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://www.linkedin.com/in/mingyu-gu-25aa761b5/" target="_blank" rel="noopener noreferrer" class="footer__link-item">LinkedIn<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 kooku's log, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>