<!doctype html>
<html class="docs-version-current" lang="ko" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.17">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kooku&#39;s log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kooku&#39;s log Atom Feed">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KVSM4B0KPY"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-KVSM4B0KPY",{})</script>
<link rel="alternate" type="application/rss+xml" href="/retrospect/rss.xml" title="Kooku&#39;s log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/retrospect/atom.xml" title="Kooku&#39;s log Atom Feed"><title data-rh="true">09 애플리케이션 조립하기 | Kooku&#x27;s log</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://kooku0.github.io/docs/books/get-your-hands-dirty-on-clean-architecture/09/"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="09 애플리케이션 조립하기 | Kooku&#x27;s log"><meta data-rh="true" name="description" content="애플리케이션이 시작될 때 클래스를 인스턴스화하고 묶기 위해서 의존성 주입 메커니즘을 이용한다. 이번 장에서는 평범한 자바로 이를 어떻게 하는지, 그리고 스프링, 스프링 부터 프레임워크에서는 이를 각각 어떻게 하는지 살펴보겠다."><meta data-rh="true" property="og:description" content="애플리케이션이 시작될 때 클래스를 인스턴스화하고 묶기 위해서 의존성 주입 메커니즘을 이용한다. 이번 장에서는 평범한 자바로 이를 어떻게 하는지, 그리고 스프링, 스프링 부터 프레임워크에서는 이를 각각 어떻게 하는지 살펴보겠다."><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://kooku0.github.io/docs/books/get-your-hands-dirty-on-clean-architecture/09/"><link data-rh="true" rel="alternate" href="https://kooku0.github.io/en/docs/books/get-your-hands-dirty-on-clean-architecture/09/" hreflang="en"><link data-rh="true" rel="alternate" href="https://kooku0.github.io/docs/books/get-your-hands-dirty-on-clean-architecture/09/" hreflang="ko"><link data-rh="true" rel="alternate" href="https://kooku0.github.io/docs/books/get-your-hands-dirty-on-clean-architecture/09/" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.13b6080a.css">
<link rel="preload" href="/assets/js/runtime~main.f385555c.js" as="script">
<link rel="preload" href="/assets/js/main.405786fc.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">본문으로 건너뛰기</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.ico" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/favicon.ico" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Kooku&#x27;s log</b></a><a class="navbar__item navbar__link" href="/blog/">블로그</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/books/">책</a><a class="navbar__item navbar__link" href="/retrospect/">회고</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kooku0/kooku0.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_S7eR toggle_TdHA toggleDisabled_f9M3"><div class="toggleButton_rCf9" role="button" tabindex="-1"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></div><input type="checkbox" checked="" class="toggleScreenReader_g2nN" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 어두운 모드)"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="맨 위로 스크롤하기" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/books/">Index</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/books/clean-code/introduction/">클린코드</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/books/object/introduction/">오브젝트</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/books/frameworkless-front-end-development/introduction/">프레임워크 없는 프론트엔드 개발</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/books/get-your-hands-dirty-on-clean-architecture/introduction/">만들면서 배우는 클린 아키텍처</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/introduction/">책 소개</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/01/">01 계층형 아키텍처의 문제는 무엇일까?</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/02/">02 의존성 역전하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/03/">03 코드 구성하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/04/">04 유스케이스 구현하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/05/">05 웹 어댑터 구현하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/06/">06 영속성 어댑터 구현하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/07/">07 아키텍처 요소 테스트하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/08/">08 경계간 매핑하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/09/">09 애플리케이션 조립하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/10/">10 아키텍처 경계 강제하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/11/">11 의식적으로 지름길 사용하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/get-your-hands-dirty-on-clean-architecture/12/">12 아키텍처 스타일 결정하기</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/books/functional-programming-in-scala/introduction/">스칼라로 배우는 함수형 프로그래밍</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/books/effective-typescript/introduction/">이펙티브 타입스크립트</a></div></li></ul></nav><button type="button" title="사이드바 숨기기" aria-label="사이드바 숨기기" class="button button--secondary button--outline collapseSidebarButton_cwdi"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_xORG"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Xlws" aria-label="breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a class="breadcrumbs__link breadcrumbsItemLink_e5ie" href="/">🏠</a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link breadcrumbsItemLink_e5ie">만들면서 배우는 클린 아키텍처</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><a class="breadcrumbs__link breadcrumbsItemLink_e5ie" href="/docs/books/get-your-hands-dirty-on-clean-architecture/09/">09 애플리케이션 조립하기</a></li></ul></nav><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">이 페이지에서</button></div><div class="theme-doc-markdown markdown"><header><h1>09 애플리케이션 조립하기</h1></header><p>애플리케이션이 시작될 때 클래스를 인스턴스화하고 묶기 위해서 의존성 주입 메커니즘을 이용한다. 이번 장에서는 평범한 자바로 이를 어떻게 하는지, 그리고 스프링, 스프링 부터 프레임워크에서는 이를 각각 어떻게 하는지 살펴보겠다.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="왜-조립까지-신경-써야-할까">왜 조립까지 신경 써야 할까?<a class="hash-link" href="#왜-조립까지-신경-써야-할까" title="제목으로 바로 가기">​</a></h2><p>왜 유스케이스와 어댑터를 그냥 필요할 때 인스턴스화하면 안 되는 걸까? 그것은 코드 의존성이 올바른 방향을 가리키게 하기 위해서다. 모든 의존성은 안쪽으로, 애플리케이션의 도메인 코드 방향으로 향해야 도메인 코드가 바깥 계층의 변경으로부터 안전하다는 점을 기억하자.
유스케이스가 영속성 어댑터를 호출해야 하고 스스로 인스턴스화한다면 코드 의존성이 잘못된 방향으로 만들어진 것이다. 이것이 바로 아웃고잉 포트 인터페이스를 생성한 이유다. 유스케이스는 인터페이스만 알아야 하고, 런타임에 이 인터페이스의 구현을 제공 받아야 한다.</p><p>이 스타일의 유익한 효과는 코드를 훨씬 더 테스트하기 쉽다는 것이다. 한 클래스가 필요로 하는 모든 객체를 생성자로 전달할 수 있다면 실제 객체 대신 목으로 전달할 수 있고, 이렇게 되면 격리된 단위 테스트를 생성하기가 쉬워진다.</p><p>해답은 아키텍처에 대해 중립적이고 인스턴스 생성을 위해 <strong>모든</strong> 클래스에 대한 의존성을 가지는 설정 컴포넌트가 있어야 한다는 것이다.</p><p><img loading="lazy" alt="img" src="/assets/images/9.1-6b107d400a70c3b942f094f0e3583712.jpeg" width="1317" height="759"></p><p>이 설정 컴포넌트는 의존성 규칙에 정의된 대로 모든 내부 계층에 접근할 수 있는 원의 가장 바깥쪽에 위치한다.</p><p>설정 컴포넌트는 우리가 제공한 조각들로 애플리케이션을 조립하는 것을 책임진다. 이 컴포넌트는 다음과 같은 역할을 수행해야 한다.</p><ul><li>웹 어댑터 인스턴스 생성</li><li>HTTP 요청이 실제로 웹 어댑터로 전달되도록 보장</li><li>유스케이스 인스턴스 생성</li><li>웹 어댑터에 유스케이스 인스턴스 제공</li><li>영속성 어댑터 인스턴스 생성</li><li>유스케이스에 영속성 어댑터 인스턴스 제공</li><li>영속성 어댑터가 실제로 데이터베이스에 접근할 수 있도록 보장</li></ul><p>보다시피 책임(&#x27;변경할 이유&#x27;)이 굉장히 많다. 단임 책임 원칙을 위반한다. 그러나 애플리케이션의 나머지 부분을 깔끔하게 유지하고 싶다면 이처럼 구성요소들을 연결하는 바깥쪽 컴포넌트가 필요하다. 그리고 이 컴포넌트는 작성하는 애플리케이션으로 조립하기 위해 애플리케이션을 구성하는 모든 컴포넌트를 알아야 한다.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="평범한-코드로-조립하기">평범한 코드로 조립하기<a class="hash-link" href="#평범한-코드로-조립하기" title="제목으로 바로 가기">​</a></h2><p>설정 컴포넌트를 구현하는 방법은 여러 가지다. 평범한 코드로 이러한 컴포넌트를 만들 수 있다.</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">package copyeditor.configuration;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Application {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    AccountRepository accountRepository = new AccountRepository();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ActivityRepository activityRepository = new ActivityRepository();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    AccountPersistenceAdapter accountPersistenceAdapter = new AccountPersistenceAdapter(accountRepository, activityRepository);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    SendMoneyUseCase sendMoneyUseCase = new SendMoneyUseService(accountPersistenceAdapter, accountPersistenceAdapter);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    SendMoneyController sendMoneyController = new SendMoneyController(sendMoneyUseCase);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    startProcessingWebRequests(sendMoneyController);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="클립보드에 코드 복사" class="copyButton_wuS7 clean-btn">복사</button></div></div><p>자바에서는 애플리케이션이 main 메서드로부터 시작된다. main 메서드 안에서 웹 컨트롤러부터 영속성 어댑터까지, 필요한 모든 클래스의 인스턴스를 생성한 후 함께 연결한다.</p><p>이 평범한 코드 방식은 애플리케이션을 조립하는 가장 기본적인 방법이다. 하지만 단점이 있다.</p><p>첫 번째로, 앞의 코드는 웹 컨트롤러, 유스케이스, 영속성 어댑터가 단 하나씩만 있는 애플리케이션을 예로 든 것이다. 완전한 애플리케이션을 실행하기 위해서는 이러한 코드를 엄청 많이 만들어야 한다.</p><p>두 번째로, 각 클래스가 속한 패키지 외부에서 인스턴스를 생성하기 때문에 이 클래스들은 전부 public이어야 한다. 이렇게 되면 유스케이스가 영속성 어댑터에 직접 접근하는 것을 막지 못한다.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="스프링의-클래스패스-스캐닝으로-조립하기">스프링의 클래스패스 스캐닝으로 조립하기<a class="hash-link" href="#스프링의-클래스패스-스캐닝으로-조립하기" title="제목으로 바로 가기">​</a></h2><p>스프링 프레임워크를 이용해서 애플리케이션을 조립한 결과물을 애플리케이션 컨텍스트라고 한다. 애플리케이션 컨텍스트는 애플리케이션을 구성하는 모든 객체(&#x27;bean&#x27;)를 포함한다.</p><p>스프링은 애플리케이션 컨텍스트를 조립하기 위한 몇 가지 방법을 제공하는데 각기 장단점이 있다.</p><p>스프링은 클래스패스 스캐닝으로 클래스패스에서 접근 가능한 모든 클래스를 확인해서 @Component 애너테이션이 붙은 클래스를 찾는다. 그리고 나서 이 애너테이션이 붙은 각 클래스의 객체를 생성한다. 이때 클래스는 필요한 모든 필드를 인자로 받는 생성자를 가지고 있어야 한다.</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">@RequiredArgsConstructor</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class AccountPersistenceAdapter implements LoadAccountPort, UpdateAccountStatePort {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  private final AccountRepository accountRepository;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  private final ActivityRepository activityRepository;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  private final AccountMapper accountMapper;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  @Override</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  public Account loadAccount(AccountId accountId, LocalDateTime baselineDate) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    //...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="클립보드에 코드 복사" class="copyButton_wuS7 clean-btn">복사</button></div></div><p>이 코드에서는 생성자를 직접 만들지 않고 Lombok 라이브러리의 @RequiredArgs Constructor 애너테이션을 이용해 모든 final 필드를 인자로 받는 생성자를 자동으로 생성했다.</p><p>그럼 스프링은 이 생성자를 찾아서 생성자의 인자로 사용된 @Component가 붙은 클래스를 찾고, 이 클래스들의 인스턴스를 만들어 애플리케이션 컨텍스트에 추가한다.</p><p>클래스패스 스캐닝 방식을 이용하면 아주 편리하게 애플리케이션을 조립할 수 있다. 적절한 곳에 @Component 애너테이션을 붙이고 생성자만 잘 만들어두면 된다.</p><p>하지만 클래스패스 스캐닝 방식에는 단점이 있다. 첫 번째로 클래스에 프레임워크에 특화된 애너테이션을 붙여야 한다는 점에서 침투적이다. 강경한 클린 아키텍처파는 이런 방식이 코드를 특정한 프레임워크와 결합시키기 때문에 사용하지 말아야 한다고 주장할 것이다.</p><p>일반적인 애플리케이션 개발에서는 필요하다면 한 클래스에 애너테이션 하나 정도는 용인할 수 있고, 리팰터링도 그리 어렵지 않게 할 수 있다.</p><p>하지만 다른 개발자들이 사용할 라이브러리나 프레임워크를 만드는 입장에서 사용하지 말아야 할 방법이다. 라이브러리 사용자가 스프링 프레임워크의 의존성에 엮이게 되기 때문이다.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="스프링의-자바-컨피그로-조립하기">스프링의 자바 컨피그로 조립하기<a class="hash-link" href="#스프링의-자바-컨피그로-조립하기" title="제목으로 바로 가기">​</a></h2><p>앞의 평범한 코드를 이용하는 방식과 비슷한데, 덜 지저분하고 프레임워크와 함께 제공되므로 모든 것을 직접 코딩할 필요가 없는 방식이다.</p><p>이 방식에서는 애플리케이션 컨텍스트에 추가할 빈을 생성하는 설정 클래스를 만든다.</p><p>예를들어, 모든 영속성 어댑터들의 인스턴스 생성을 담당하는 설정 클래스를 하나 만들어보자.</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">@EnableJpaRepositories</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class PersistenceAdapterConfiguration {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  @Bean</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  AccountPersistenceAdapter accountPersistenceAdapter(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    AccountRepository accountRepository,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ActivityRepository activityRepository,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    AccountMapper accountMapper</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  ) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return new AccountPersistenceAdapter(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      accountRepository,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      activityRepository,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      accountMapper</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  @Bean</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  AccountMapper accountMapper() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return new AccountMapper();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="클립보드에 코드 복사" class="copyButton_wuS7 clean-btn">복사</button></div></div><p>@Configuration 애너테이션을 통해 이 클래스가 스프링의 클래스패스 스캐닝에서 발견해야 할 설정 클래스임을 표시해둔다. 그러므로 사실 여전히 클래스패스 스캐닝을 사용하고 있는 것이기는 하다. 하지만 모든 빈을 가져오는 대신 설정 클래스만 선택하기 때문에 좋다.</p><p>이 방식에서는 클래스패스 스캐닝 방식과 달리 @Component 애너테이션을 코드 여기 저기에 붙이도록 강제하지 않는다. 그래서 애플리케이션 계층을 스프링 프레임워크에 대한 의존성 없이 깔끔하게 유지할 수 있다.</p><p>하지만 이 방법에도 문제점은 있다. 설정 클래스가 생성하는 빈이 설정 클래스와 같은 패키지에 존재하지 않는다면 이 빈들을 public으로 만들어야 한다.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까">유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?<a class="hash-link" href="#유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까" title="제목으로 바로 가기">​</a></h2><p>스프링과 스프링 부트는 개발을 편하게 만들어주는 다양한 기능들을 제공한다. 그중 하나가 바로 애플리케이션 개발자로서 우리가 제공하는 클래스들을 이용해서 애플리케이션을 조립하는 것이다.</p><p>클래스패스 스캐닝은 아주 편리한 기능이다. 스프링에게 패키지만 알려주면 거기서 찾은 클래스로 애플리케이션을 조립한다. 이를 통해 애플리케이션 전체를 고민하지 않고도 빠르게 개발할 수 있다.</p><p>하지만 코드의 규모가 커지면 금방 투명성이 낮아진다. 어떤 빈이 애플리케이션 컨텍스트에 올라오는지 정확히 알 수 없고, 테스트에서 애플리케이션 컨텍스트의 일부만 독립적으로 띄우기가 어려워진다.</p><p>반면 애플리케이션 조립을 책임지는 전용 설정 컴포넌트를 만들면 애플리케이션의 이러한 책임으로부터 자유로워진다. 이 방식을 이용하면 서로 다른 모듈로부터 독립되어 코드 상에서 손쉽게 옮겨 다닐수 있는 응집도가 매우 높은 모듈을 만들 수 있다. 하지만 늘 그렇듯이 설정 컴포넌트를 유지하는데 약간의 시간을 추가로 들여야 한다.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/kooku0/kooku0.github.io/edit/main/docs/books/get-your-hands-dirty-on-clean-architecture/09.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>페이지 편집</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="문서 탐색"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/books/get-your-hands-dirty-on-clean-architecture/08/"><div class="pagination-nav__sublabel">이전</div><div class="pagination-nav__label">08 경계간 매핑하기</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/books/get-your-hands-dirty-on-clean-architecture/10/"><div class="pagination-nav__sublabel">다음</div><div class="pagination-nav__label">10 아키텍처 경계 강제하기</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#왜-조립까지-신경-써야-할까" class="table-of-contents__link toc-highlight">왜 조립까지 신경 써야 할까?</a></li><li><a href="#평범한-코드로-조립하기" class="table-of-contents__link toc-highlight">평범한 코드로 조립하기</a></li><li><a href="#스프링의-클래스패스-스캐닝으로-조립하기" class="table-of-contents__link toc-highlight">스프링의 클래스패스 스캐닝으로 조립하기</a></li><li><a href="#스프링의-자바-컨피그로-조립하기" class="table-of-contents__link toc-highlight">스프링의 자바 컨피그로 조립하기</a></li><li><a href="#유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까" class="table-of-contents__link toc-highlight">유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog/">블로그</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/books/">책</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/kooku0/kooku0.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.linkedin.com/in/mingyu-gu-25aa761b5/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>LinkedIn<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 kooku's log, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.f385555c.js"></script>
<script src="/assets/js/main.405786fc.js"></script>
</body>
</html>