<!doctype html>
<html lang="ko" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-books/functional-programming-in-scala/04">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">04 예외를 이용하지 않은 오류 처리 | Kooku&#x27;s log</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://kooku0.github.io/docs/books/functional-programming-in-scala/04/"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="04 예외를 이용하지 않은 오류 처리 | Kooku&#x27;s log"><meta data-rh="true" name="description" content="제1장에서 예외(exception)를 던지는 것이 하나의 부수 효과임을 간단히 언급했다. 이번 장에서는 오류를 함수적으로 제기하고 처리하는 데 필요한 기본 원리들을 배울 것이다. 여기서 핵심은, 실패 상황과 예외를 보통의 값으로 표현할 수 있으며, 일반적인 오류 처리&amp;복구 패턴을 추상화한 고차 함수를 작성할 수 있다는 것이다. 오류를 값으로 돌려준다는 함수적 해법은 더 안전하고 참조 투명성을 유지한다는 장점이 있다. 게다가 고차 함수 덕분에 예외의 주된 이점인 오류 처리 논리의 통합(consolidation of error-handling logic)도 유지된다."><meta data-rh="true" property="og:description" content="제1장에서 예외(exception)를 던지는 것이 하나의 부수 효과임을 간단히 언급했다. 이번 장에서는 오류를 함수적으로 제기하고 처리하는 데 필요한 기본 원리들을 배울 것이다. 여기서 핵심은, 실패 상황과 예외를 보통의 값으로 표현할 수 있으며, 일반적인 오류 처리&amp;복구 패턴을 추상화한 고차 함수를 작성할 수 있다는 것이다. 오류를 값으로 돌려준다는 함수적 해법은 더 안전하고 참조 투명성을 유지한다는 장점이 있다. 게다가 고차 함수 덕분에 예외의 주된 이점인 오류 처리 논리의 통합(consolidation of error-handling logic)도 유지된다."><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://kooku0.github.io/docs/books/functional-programming-in-scala/04/"><link data-rh="true" rel="alternate" href="https://kooku0.github.io/en/docs/books/functional-programming-in-scala/04/" hreflang="en"><link data-rh="true" rel="alternate" href="https://kooku0.github.io/docs/books/functional-programming-in-scala/04/" hreflang="ko"><link data-rh="true" rel="alternate" href="https://kooku0.github.io/docs/books/functional-programming-in-scala/04/" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kooku&#39;s log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kooku&#39;s log Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KVSM4B0KPY"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-KVSM4B0KPY",{})</script>


<link rel="alternate" type="application/rss+xml" href="/retrospect/rss.xml" title="Kooku&#39;s log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/retrospect/atom.xml" title="Kooku&#39;s log Atom Feed"><link rel="stylesheet" href="/assets/css/styles.19dc9a9f.css">
<link rel="preload" href="/assets/js/runtime~main.879624a5.js" as="script">
<link rel="preload" href="/assets/js/main.c4a10850.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="본문으로 건너뛰기"><a href="#" class="skipToContent_fXgn">본문으로 건너뛰기</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.ico" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/favicon.ico" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Kooku&#x27;s log</b></a><a class="navbar__item navbar__link" href="/blog/">블로그</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/books/">책</a><a class="navbar__item navbar__link" href="/retrospect/">회고</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kooku0/kooku0.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 어두운 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 어두운 모드)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="맨 위로 스크롤하기" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/books/">책 목록</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/books/clean-code/introduction/">클린코드</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/books/object/introduction/">오브젝트</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/books/frameworkless-front-end-development/introduction/">프레임워크 없는 프론트엔드 개발</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/books/get-your-hands-dirty-on-clean-architecture/introduction/">만들면서 배우는 클린 아키텍처</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/books/functional-programming-in-scala/introduction/">스칼라로 배우는 함수형 프로그래밍</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/functional-programming-in-scala/introduction/">책 소개</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/books/functional-programming-in-scala/04/">04 예외를 이용하지 않은 오류 처리</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/books/effective-typescript/introduction/">이펙티브 타입스크립트</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/books/the-pragmatic-programmer/introduction/">실용주의 프로그래머</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/books/test-driven-development/introduction/">테스트 주도 개발</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/books/functional-programming-in-javascript/introduction/">함수형 자바스크립트</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/books/designing-for-performance/introduction/">디자이너를 위한 웹 성능 최적화 기법</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/books/grokking-simplicity/introduction/">쏙쏙 들어오는 함수형 코딩</a></div></li></ul></nav><button type="button" title="사이드바 숨기기" aria-label="사이드바 숨기기" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="홈" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">스칼라로 배우는 함수형 프로그래밍</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">04 예외를 이용하지 않은 오류 처리</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">이 페이지에서</button></div><div class="theme-doc-markdown markdown"><header><h1>04 예외를 이용하지 않은 오류 처리</h1></header><p>제1장에서 예외(exception)를 던지는 것이 하나의 부수 효과임을 간단히 언급했다. 이번 장에서는 오류를 함수적으로 제기하고 처리하는 데 필요한 기본 원리들을 배울 것이다. 여기서 핵심은, 실패 상황과 예외를 보통의 값으로 표현할 수 있으며, 일반적인 오류 처리&amp;복구 패턴을 추상화한 고차 함수를 작성할 수 있다는 것이다. 오류를 값으로 돌려준다는 함수적 해법은 더 안전하고 참조 투명성을 유지한다는 장점이 있다. 게다가 고차 함수 덕분에 예외의 주된 이점인 <strong>오류 처리 논리의 통합</strong>(consolidation of error-handling logic)도 유지된다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="41-예외의-장단점">4.1 예외의 장단점<a class="hash-link" href="#41-예외의-장단점" title="제목으로 바로 가기">​</a></h2><p>예외가 왜 참조 투명성을 해칠까?</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">목록 4.1 예외를 던지고 받기</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def failingFn(i: Int): Int = {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  val y: Int = throw new Exception(&quot;fail!&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  try {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    val x = 42 + 5</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    x + y</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  catch { case e: Exception =&gt; 43 }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>failingFn을 호출하면 예상대로 오류가 발생한다.</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token operator">&gt;</span><span class="token plain"> failingFn</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token number">12</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">java.lang.Exception: fail</span><span class="token operator">!</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  at .failingFn</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token operator">&lt;</span><span class="token plain">console</span><span class="token operator">&gt;</span><span class="token plain">:8</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(248, 248, 242)">..</span><span class="token plain">.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>y가 참조에 투명하지 않음을 증명할 수 있다. 만일 x + y의 y를 throw new Exception(&quot;fail!&quot;)로 치환하면 그전과는 다른 결과가 나온다. 이제는 예외를 잡아서 43을 돌려주는 try 블록 안에서 예외가 발생하기 때문이다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def failingFn2(i: Int): Int = {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  try {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    val x = 42 + 5</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    x + ((throw new Exception(&quot;fail!&quot;)): Int)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  catch { case e: Exception =&gt; 43 }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token operator">&gt;</span><span class="token plain"> failingFn</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token number">12</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">res1: Int </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">43</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>참조 투명성에서 참조에 투명한 표현식의 의미는 <strong>문맥(context)에 의존하지 않는다</strong>라는 것을 의미하고, 지역적으로 추론할 수 있지만 참조에 투명하지 않은 표현식의 의미는 <strong>문맥에 의존적이고(context-dependent)</strong> 좀 더 전역의 추론이 필요하다는 것으로 이해해도 될 것이다.
예를 들어 참조 투명 표현식 42 + 5의 의미는 그 표현식을 포함한 더 큰 표현식에 의존하지 않는다. 그 표현식은 항상, 그리고 영원히 47과 같다. 그러나 <code>throw new Exception(&quot;fail&quot;)</code>이라는 표현식의 의미는 문맥에 크게 의존한다. 방금 보았듯이, 이 표현식은 try 블록에 포함되어 있는지, 있다면 어떤 try 블록인지에 따라 달라진다.</p><p>예외의 주된 문제 두 가지는 다음과 같다.</p><ul><li><p>방금 논의했듯이, <strong>예외는 참조 투명성을 위반하고 문맥 의존성을 도입한다.</strong> 따라서 치환 모형의 간단한 추론이 불가능해지고 예외에 기초한 혼란스러운 코드가 만들어진다.</p></li><li><p><strong>예외는 형식에 안전하지 않다.</strong> failingFn의 형식인 Int =&gt; Int만 보고는 이 함수가 예외를 던질 수 있다는 사실을 전혀 알 수 없으며, 그래서 컴파일러는 failingFn의 호출자에게 그 예외들을 처리하는 방식을 결정하라고 강제할 수 없다.</p></li></ul><p>이런 단점들이 없으면서도 예외의 기본 장점인 <strong>오류 처리의 통합과 중앙집중화</strong>를 유지하는(오류 처리 논리를 코드 기반의 여기저기에 널어 놓지 않아도 되도록) 대안이 있으면 좋을 것이다. 지금부터 소개하는 대안 기법은 &quot;예외를 던지는 대신, 예외적인 조건이 발생했음을 뜻하는 값을 돌려준다&quot;라는 오래된 착안에 기초한다. 이 기법에서는 오류 부호를 직접 돌려주는 대신 그런 &#x27;미리 정의해 둘 수 있는 값들&#x27;을 대표하는 새로운 일반적 형식을 도입하고, 오류의 처리와 전파에 관한 공통적인 패턴들을 고차 함수들을 이용해서 캡슐화한다. 이 전략은 <strong>형식에 완전히 안전하며</strong>, 실수를 미리 발견할 수 있다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="42-예외의-가능한-대안들">4.2 예외의 가능한 대안들<a class="hash-link" href="#42-예외의-가능한-대안들" title="제목으로 바로 가기">​</a></h2><p>다음은 목록의 평균(mean)을 계산하는 함수이다. 빈 목록에 대해서는 평균의 정의되지 않는다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def mean(xs: Seq[Double]): Double =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  if (xs.isEmpty)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    throw new ArithmeticException(&quot;mean of empty list!&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  else xs.sum / xs.length</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>mean 함수는 소위 <strong>부분 함수(partical function)</strong>의 예이다. 부분 함수란 일부 입력에 대해서는 정의되지 않는 함수를 말한다.</p><p>자신이 받아들이는 입력에 대해 입력 형식만으로는 결정되지 않는 어떤 가정을 두는 함수는 대부분 부분 함수이다. 받아들일 수 없는 입력에 대해 예외를 던질 수도 있지만, 꼭 그래야 하는 것은 아니다. 대안 몇 가지를 살펴보자.</p><p>첫 번째 대안은 Double 형식의 가짜 값을 돌려주는 것이다. 모든 경우에 그냥 <code>xs.sum / xs.length</code>를 돌려준다면 빈 목록에 대해서는 <code>0.0 / 0.0</code>을 돌려주게 되는데, 이는 Double.Nan이다. 아니면 다른 어떤 경계 값(sentinel value)이나 null을 돌려줄 수도 있다. 이런 부류의 접근방식은 예외 기능이 없는 언어에서 오류를 처리하는데 흔히 쓰인다. 그러나 이 책에서는 이런 접근방식을 거부한다. 이유는 여러 가지이다.</p><ul><li>오류가 소리없이 전파될 수 있다. 호출자가 이런 오류 점검을 실수로 빼먹어도 컴파일러가 경고해주지 않는다.</li><li>실수의 여지가 많다는 점 외에, 호출하는 쪽에 호출자가 &#x27;진짜&#x27; 결과를 받았는지 점검하는 명식적 if 문들이 늘어난다.</li><li>다형적 코드에는 적용할 수 없다. 출력 형식에 따라서는 그 형식의 경계 값을 결정하는 것이 <strong>불가능</strong>할 수도 있다.</li><li>호출자에게 특별한 방침이나 호출 규약을 요구한다. mean 함수를 제대로 사용하려면 호출자가 그냥 mean을 호출해서 그 결과를 사용하는 것 이상의 작업을 수행해야한다. 이렇게 되면 모든 인수를 균일한 방식으로 처리해야 하는 고차 함수에 전달하기 어려워진다.</li></ul><p>또 다른 대안은 함수가 입력을 처리할 수 없는 상황에 처했을 때 무엇을 해야 하는지 말해주는 인수를 호출자가 지정하는 것이다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def mean_1(xs: IndexedSeq[Double], onEmpty: Double): Double =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  if (xs.isEmpty) onEmpty</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  else xs.sum / xs.length</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이렇게 하면 mean은 부분함수가 아닌 완전 함수(total function)가 된다. 그러나 여기에는 결과가 정의되지 않는 경우의 처리 방식을 함수의 <strong>직접적인</strong> 호출자가 알고 있어야 하고 그런 경우에도 항상 하나의 Double 값을 결과로 돌려주어야 한다는 단점이 있다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="43-option-자료-형식">4.3 Option 자료 형식<a class="hash-link" href="#43-option-자료-형식" title="제목으로 바로 가기">​</a></h2><p>해법은, 함수가 항상 답을 내지는 못한다는 점을 반환 형식을 통해서 명시적으로 표현하는 것이다. 이를, 오류 처리 전략을 호출자에게 미루는 것으로 생각해도 된다. 이를 위해 Option이라는 새로운 형식을 도입한다. 이 형식은 스칼라 표준 라이브러리에도 존재하나, 학습을 위해 직접 만들어 본다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">sealed trait Option[+A]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">case class Some[+A](get: A) extends Option[A]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">case object None extends Option[Nothing]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Option에는 두 개의 경우 문이 있다. Option을 정의할 수 있는 경우에는 Some이 되고, 정의할 수 없는 경우에는 None이 된다.</p><p>이제 Option을 이용해서 mean을 구현하면 다음과 같은 코드가 된다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def mean(xs: Seq[Double]): Option[Double] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  if (xs.isEmpty) None</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  else Some(xs.sum / xs.length)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이제는 이 함수의 결과가 항상 정의되지는 않는다는 사실이 함수의 반환 형식에 반영되어 있다. 함수가 항상 선언된 반환 형식(Optionp<!-- -->[Double]<!-- -->)의 결과를 돌려주어야 한다는 점은 여전하므로, mean은 이제 하나의 <strong>완전 함수</strong>이다. 이 함수는 입력 형식의 모든 값에 대해 정확히 하나의 출력 형식 값을 돌려준다.</p><img loading="lazy" src="/assets/images/option-8ab003f6580341c4e2302136db018720.jpeg" alt="option" class="img_ev3q"><h3 class="anchor anchorWithStickyNavbar_LWe7" id="431-option의-사용-패턴">4.3.1 Option의 사용 패턴<a class="hash-link" href="#431-option의-사용-패턴" title="제목으로 바로 가기">​</a></h3><p>부분 함수는 프로그래밍에서 흔히 볼 수 있으며, FP에서는 그런 부분성을 흔히 Option 같은 자료 형식으로 처리한다. Option이 편리한 이유는, 오류 처리의 공통 패턴을 고차 함수들을 이용해서 추출함으로써 예외 처리 코드에 흔히 수반되는 판에 박힌 코드를 작성하지 않아도 된다는 점이다.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="option에-대한-기본적인-함수들">Option에 대한 기본적인 함수들<a class="hash-link" href="#option에-대한-기본적인-함수들" title="제목으로 바로 가기">​</a></h4><p>Option은 최대 하나의 원소를 담을 수 있다는 점을 제외하면 List와 비슷하다. 실제로 Option에는 이전에 본 여러 List 함수에 대응되는 함수들이 있다. 이번 절에서는 함수들을 가능하면 Option 특질(trait)의 본문에 집어넣는다. 그러면 <code>fn(obj, arg1)</code> 대신 <code>obj.fn(arg1)</code> 이나 <code>obj fn arg1</code>로 호출할 수 있다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">목록 4.2 Option 자료 형식</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">trait Option[+A] {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  def map[B](f: A =&gt; B): Option[B]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  def faltMap[B](f: A =&gt; Option[B]): Option[B]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  def getOrElse[B &gt;: A](default: =&gt; B): B</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  def orElse[B &gt;: A](ob: =&gt; Option[B]): Option[B]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  def filter(f: A =&gt; Boolean): Option[A]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">map: 만일 Option이 None이 아니면 f를 적용한다.</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def map[B](f: A =&gt; B): Option[B] = this match</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  case None =&gt; None</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  case Some(a) =&gt; Some(f(A))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>map 함수는 Option 안의 결과(가 있다면)를 반환하는데 사용할 수 있다. 이를 요류가 발생하지 않았다는 가정하에 계산하는 것으로 생각해도될 것이다. 또한, 이는 오류 처리를 나중의 코드에 미루는 수단이기도 하다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">case class Employee(name: String, department: String)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">def lookupByName(name: String): Option[Employee] = ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">val joeDepartment: Option[String] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  lookupByName(&quot;Joe&quot;).map(_.department)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이 예에서 <code>lookUpByName(&quot;Joe&quot;)</code>는 <code>Option[Employee]</code>를 돌려준다. 그것을 map으로 변환하면 Joe가 속한 부서의 이름을 뜻하는 <code>Option[String]</code>이 나온다. 여기서 <code>loopupByName(&quot;Joe&quot;)</code>의 결과를 명시적으로 점검하지 않음을 주목하기 바란다. 그냥 오류가 전혀 발생하지 않았다는 듯이 map의 인수 안에서 계산을 계속 진행한다. 만일 <code>loopupByName(&quot;Joe&quot;)</code>가 None을 돌려주었다면 계산의 나머지 부분이 취소되어서 map은 <code>_.department</code> 함수를 전혀 호출하지 않는다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">faltMap: 만일 Option이 None이 아니면 f(실패할 수 있음)를 적용한다.</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def faltMap[B](f: A =&gt; Option[B]): Option[B] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  map(f).getOrElse(None)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>flatMap을 이용하면 여러 단계로 이루어진 계산을 수행하되 어떤 단계라도 실패하면 그 즉시 나머지 모든 과정이 취소되는 방식으로 수행할 수 있다. 이는 None.flatMap(f)가 f를 실행하지 않고 즉시 None을 돌려주기 때문이다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">getOrElse</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def getOrElse[B &gt;: A](default: =&gt; B): B = this match</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  case None =&gt; default</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  case Some(a) =&gt; a</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>None일 시 default를 반환한다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">orElse</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def orElse[B &gt;: A](ob: =&gt; Option[B]): Option[B] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  map(Some(_)).getOrElse(ob)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>orElse는 getOrElse와 비슷하되 첫 Option이 정의되지 않으면 다른 Option을 돌려준다는 점이 다르다. 이는 실패할 수 있는 계산이 성공하지 않으면 둘째 것을 시도하고자 할 때 유용하다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">filter: 값이 f를 만족하지 않으면 Some을 None으로 변화한다.</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def filter(f: A =&gt; Boolean): Option[A]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  case Some(a) if f(a) =&gt; this</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  case _ =&gt; None</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>filter는 성공적인 값이 주어진 술어와 부합하지 않을 때 성공을 실패로 변환하는데 사용할 수 있다.</p><p>흔한 사용 패턴은 map, faltMap, filter의 임의의 조합을 이용해서 Option을 변환하고 제일 끝에서 getOrElse를 이용해서 오류 처리를 수행하는 것이다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">val dept: String =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  loolupByName(&quot;Joe&quot;).</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  map(_.dept).</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  filter(_ != &quot;Accounting&quot;).</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  getOrElse(&quot;Default Dept&quot;)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>흔한 관용구로, <code>o.getOrElse(throw new Exception(&quot;FAIL&quot;))</code>은 Option의 None 경우를 예외로 처리되게 만든다. 합리적인 프로그램이라면 결코 예외를 잡을 수 없는 상황에서만 예외를 사용하면 된다. 어떤 호출자가 복구 가능한 오류로 처리할 수 있을 만한 상황이라면 예외 대신 Option을 돌려주어 호출자에게 유연성을 부여한다.</p><p>이상에서 보듯이 오류를 보통의 값으로서 돌려주면 코드를 짜기가 편해지며, 고차 함수를 사용함으로써 예외의 주된 장점인 오류 처리의 통합과 격리도 유지할 수 있다. 계산의 매 단계마다 None을 점검할 필요가 없음을 주목하기 바란다. 그냥 일련의 변환을 수행하고 나중에 원하는 장소에서 None을 점검하고 처리하면 된다. 또한 추가적인 안전성도 얻게 된다. <code>Option[A]</code>는 A와는 다른 형식이므로, None일 수 있는 상황의 처리를 명시적으로 지연 또는 수행하지 않으면 컴파일러가 오류를 낸다.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="432-예외-지향적-api의-option-합성과-승급-감싸기">4.3.2 예외 지향적 API의 Option 합성과 승급, 감싸기<a class="hash-link" href="#432-예외-지향적-api의-option-합성과-승급-감싸기" title="제목으로 바로 가기">​</a></h3><p>일단 Option을 사용하기 시작하면 코드 기반 전체에 Option이 번지게 되리라는 성급한 결론을 내리는 독자도 있을 것이다. 즉 Option을 받거나 돌려주는 메서드를 호출하는 모든 코드를 Some이나 None을 처리하도록 수정해야 한다고 추측할 수 있다. 그러나 실제로는 그런 부담을 질 필요가 없다. 보통의 함수를 Option에 대해 작용하는 함수로 <strong>승급시킬(lift)</strong> 수 있기 때문이다.</p><p>예를 들어 map 함수가 있으면 <code>Option[A]</code> 형식의 값들을 <code>A =&gt; B</code> 형식의 함수를 이용해서 변환한 후 하나의 <code>Option[B]</code>를 결과로 돌려주게 하는 것이 가능하다. 이를 map이 <code>A =&gt; B</code> 형식의 함수 f를 <code>Option[A] =&gt; Option[B]</code> 형식의 함수로 변환한다고 이해해도 좋을 것이다. 구체적인 방법은 다음과 같다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def lift[A, B](f: A =&gt; B): Option[A] =&gt; Option[B] = _ map f</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이러한 lift가 있으면 지금까지 나온 그 어떤 함수라도 한 Option 값의 <strong>문맥 안에서</strong> 작용하도록 변환할 수 있다. 예를 하나 보다.</p><p>자동차 보험 회사의 웹 사이트에서 사용자가 즉석 온라인 견적을 요구하는 양식을 제출하는 페이지를 위한 논리를 구현한다고 하자. 양식에 담긴 정보를 분석한 후, 결과적으로는 다음과 같은 보험료율 함수를 호출하게 될 것이다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">두 가지 핵심 요인으로 연간 자동차 보험료를 계산하는 공식</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def insuranceRateQuote(age: Int, numberOfSpeedingTickets: Int): Double</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이 함수를 호출하려면 고객의 나이와 고객이 받은 속도위반 딱지의 수를 알아야 한다. 그런데 고객이 제출한 웹 페이지의 양식에서 문자열 파싱이 실패할 수 있다. 주어진 문자열 s를 <code>s.toInt</code>를 이용해서 Int로 파싱해 보았을 때 만일 문자열이 유효한 정수를 나타내지 않는다면 <code>s.toInt</code>는 NumberFormatException이라는 예외를 던진다.</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token operator">&gt;</span><span class="token plain"> </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;112&quot;</span><span class="token plain">.toInt</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">res0: Int </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">112</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;hello&quot;</span><span class="token plain">.toInt</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">java.lang.NumberFormatException: For input string: </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;hello&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(248, 248, 242)">..</span><span class="token plain">.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>그럼 toInt의 예외 기반 API를 Option으로 변환하고 <code>parseInsuranceRateQuote</code> 함수를 구현해 보자. 이 함수는 나이와 속도위반 딱지 수를 받고, 두 값의 정수 파싱이 성공하면 <code>insuranceRateQuote</code>를 호출한다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">목록 4.3 Option의 용례</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def parseInsuranceRateQuote(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    age: String,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    numberOfSpeedingTickets: String): Option[Double] = {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  val optAge: Option[Int] = Try(age.toInt)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  val optTickets: Option[Int] = Try(numberOfSpeedingTickets.toInt)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  insuranceRateQuote(optAge, optTickets)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// A 인수를 엄격하지 않는 방식으로 받아들인다. a를 평가하는 도중에 예외가 발생하면 그것을 None으로 변환할 수 있게 하기 위해서이다.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">def Try[A](a: =&gt; A): Option[A] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  try Some(a)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  catch { case e: Exception =&gt; None }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Try 함수는 예외 기반 API를 Option 지향적 API로 변환하는데 사용할 수 있는 범용 함수이다. 이 함수는 엄격하지 않은 또 다른 &#x27;게으른(lazy)&#x27; 인수를 사용한다. a의 형식 주해 =&gt; A가 바로 그 점을 나타낸다.</p><p>그런데 문제점이 하나 있다. optAge와 optTickets을 파싱해서 <code>Option[Int]</code>를 얻은 후 <code>insuranceRateQuote</code> 함수를 호출해야 하는데, 그 함수는 두 개의 Int 값을 받는다는 점이다. <code>Option[Int]</code> 값들을 받도록 <code>insuranceRateQuote</code>를 다시 작성해야할까? 그렇지 않다. <code>insuranceRateQuote</code>를 변경하면 관심사들이 얽혀서 한 계산이 항상 이전 계산의 성공 여부를 신경 써야 하는 사태가 벌어진다.
<code>insuranceRateQuote</code>를 수정하는 대신, 그것을 두 생략적(optional) 값들의 문맥에서 작동하도록 승급시키는 것이 바람직하다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">연습문제 4.3</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">// 두 Option 값을 이항 함수(binary function)를 이용해서 결합하는 일반적 함수 map2를 작성하라.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// 두 Option 값 중 하나라도 None이면 map2의 결과 역시 None이어야 한다. 서명은 다음과 같다.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">def map2[A, B, C](a: Option[A], b: Option[B])(f: (A, B) =&gt; C): Option[C] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  a.flatMap(aa =&gt; b.map(bb =&gt; f(aa, bb)))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>다음은 이러한 map2로 <code>parseInsuranceRateQuote</code>를 구현한 예이다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def parseInsuranceRateQuote(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    age: String,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    numberOfSpeedingTickets: String): Option[Double] = {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  val optAge: Option[Int] = Try { age.toInt } // 인수 하나를 받는 함수는 중괄호 대신 대괄호로 호출할 수 있다. Try(age.onInt)와 같다.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  val optTicket: Option[Int] = Try { numberOfSpeedingTickets.toInt }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  map2(optAge, optTickets)(insuranceRateQuote) // 둘 중 하나라도 파싱에 실패하면 즉시 None을 돌려준다.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>map2 함수는 인수가 두 개인 그 어떤 함수라도 아무 수정없이 &quot;Option에 대응하기&quot; 만들 수 있음을 의미한다. 예전에 만들어 둔 함수라도 Option의 문맥에서 작동하도록 승급시킬 수 있다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">연습문제 4.4</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">// Option들의 목록을 받고 그 목록에 있는 모든 Some 값으로 구성된 목록을 담은 Option을 돌려주는 함수 sequence를 작성하라. 원래의 목록에 None이 하나라도 있으면 함수의 결과도 None이어야 한다. 그렇지 않으면 원래의 목록에 있는 모든 값의 목록을 담은 Some을 돌려주어야 한다.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">def sequence[A](a: List[Option[A]]): Option[List[A]] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  as match</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    case Nil =&gt; Some(Nil)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    case h :: t =&gt; h.flatMap(hh =&gt; sequence(t).map(hh :: _))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>실패할 수 있는 함수를 목록에 사상했을 때 만일 목록의 원소 중 하나라도 None을 돌려주면 전체 결과가 None이 되게 해야 할 때도 있다. 목록에 담긴 String 값들 전부가 Option<!-- -->[Int]<!-- -->로의 파싱에 성공해야 한다면 map의 결과들을 sequence로 순차 결합하면 된다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def parseInts(a: List[String]): Option[List[Int]] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  sequence(a map (i =&gt; Try(i.toInt)))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>그러나 안타깝게도 이 접근방식은 목록을 두 번 훑어야 하기 때문에 비효율적이다. 한 번은 String을 <code>Option[Int]</code>로 변환하기 위해, 또 한 번은 그 <code>Option[Int]</code> 값들을 하나의 <code>Option[List[Int]]</code>로 결합하기 위해서이다. 이러한 map의 결과들의 순차 결합은 충분히 흔한 작업이기 때문에 다음과 같은 일반적 함수 traverse를 만들어 둘 필요가 있다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def traverse[A, B](a: List[A])(f: A =&gt; Option[B]): Option[List[B]] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   as match</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    case Nil =&gt; Some(Nil)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    case h::t =&gt; map2(f(h), traverse(t)(f))(_ :: _)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>map, lift, sequence, traverse, map2 같은 함수들이 있으면, 생략적 값을 다루기 위해 기존 함수를 수정해야 할 일이 <strong>전혀</strong> 없어야 하는 것이 정상이다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="44-either-자료-형식">4.4 Either 자료 형식<a class="hash-link" href="#44-either-자료-형식" title="제목으로 바로 가기">​</a></h2><p>이번 장의 핵심은 실패와 예외를 보통의 값으로 표현할 수 있다는 점과 오류 처리 및 복구에 대한 공통의 패턴을 추상화하는 함수를 작성할 수 있다는 점이다. Option의 경우 예외적인 조건이 발생했을 때 무엇이 잘못되었는지에 대한 정보를 제공하지 못한다는 단점을 아마 눈치챘을 것이다. 실패 시 이 형식은 그냥 유효한 값이 없음을 뜻하는 None을 돌려줄 뿐이다. 예외가 발생한 경우 실제로 발생한 오류가 어떤 것인지 알 수 있는 무언가를 돌려주면 좋을 것이다. 이번 절에서는 Option을 간단하게 확장해서, 실패의 <strong>원인</strong>을 추적할 수 있는 Either 자료 형식을 만들어 본다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">sealed trait Either[+E, +A]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">case class Left[+E](value: E) extends Either[E, Nothing]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">case class Right[+A](value: A) extends Either[Nothing, A]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Option처럼 Either도 case가 두 개 뿐이다. Option과의 본질 적인 차이는, 두 경우 모두 값을 가진다는 것이다. 이 형식은 두 형식의 <strong>분리합집합</strong>이라 할 수 있다. 이 형식을 성공 또는 실패를 나타내는 데 사용할 때에는, Right 생성자를 성공을 나타내는데 사용하고 Left는 실패에 사용한다. 왼쪽 형식 매개변수의 이름으로는 error를 의미하는 E를 사용한다.</p><p>mean 예제를 다시 보자. 이번에는 실패의 경우에 String을 돌려준다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def mean(xs: IndexedSeq[Double]): Either[String, Double] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  if (xs.isEmpty)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Left(&quot;mean of empty list!&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  else</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Right(xs.sum / xs.length)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>오류에 대한 추가 정보, 이를테면 소스 코드에서 오류가 발생한 위치를 알 수 있는 스택 추적 정보가 있으면 편리한 경우가 종종 있다. 그런 경우 Either의 Left 쪽에서 그냥 예외를 돌려주면 된다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def safeDiv(x: Int, y: Int): Either[Exception, Int] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  try Right(x / y)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  catch { case e: Exception =&gt; Left(e) }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Option에서 했듯이, 던져진 예외를 값으로 변환한다는 이러한 공통의 패턴을 추출한 함수 Try를 작성해 보자.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def Try[A](a: =&gt; A): Either[Exception, A] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  try Right(a)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  catch { case e: Exception =&gt; Left(e) }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">trait Either[+E, +A] {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  def map[B](f: A =&gt; B): Either[E, B] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    this match</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      case Right(a) =&gt; Right(f(a))</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      case Left(e) =&gt; Left(e)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  def flatMap[EE &gt;: E, B](f: A =&gt; Either[EE, B]): Either[EE, B] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    this match</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      case Left(e) =&gt; Left(e)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      case Right(a) =&gt; f(a)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  def orElse[EE &gt;: E, AA &gt;: A](b: =&gt; Either[EE, AA]): Either[EE, AA] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    this match</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      case Left(_) =&gt; b</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      case Right(a) =&gt; Right(a)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  def map2[EE &gt;: E, B, C](b: Either[EE, B])(f: (A, B) =&gt; C):</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Either[EE, C] = for { a &lt;- this; b1 &lt;- b } yield f(a,b1)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이러한 정의들이 있으면 Either를 for-함축에 사용할 수 있다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def parseInsuranceRateQuote(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    age: String,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    numberOfSpeedingTickets: String): Either[Exception, Double] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  for {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    a &lt;- Try { age.toInt }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    tickets &lt;- Try { numberOfSpeedingTickets.toInt }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  } yield insuranceRateQuote(a, Tickets)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이제는 실패 시 그냥 None이 아니라 발생한 실제 예외에 대한 정보를 얻게 되었다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">sequence, traverse</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def traverse[E,A,B](as: List[A])(f: A =&gt; Either[E, B]): Either[E, List[B]] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  as match</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    case Nil =&gt; Right(Nil)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    case h :: t =&gt; f(h).map2(traverse(t)(f))(_ :: _)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">def sequence[E,A](as: List[Either[E,A]]): Either[E,List[A]] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  traverse(as)(x =&gt; x)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>함수 mkPerson은 주어진 이름과 나이의 유효성을 점검한 후 유효한 Person을 생성한다.</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">case class Person(name: Name, age:Age)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">sealed class Name(val value: String)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">sealed class Age(val value: Int)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">def mkName(name: String): Either[String, Name] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  if (name == &quot;&quot; || name == null) Left(&quot;Name is empty.&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  else Right(new Name(name))</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">def mkAge(age: Int): Either[String, Age] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  if (age &lt; 0) Left(&quot;Age is out of range.&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  else Right(new Age(age))</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">def mkPerson(name: String, age: Int): Either[String, Person] =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  mkname(name).map2(mkAge(age))(Person(_, _))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="45-요약">4.5 요약<a class="hash-link" href="#45-요약" title="제목으로 바로 가기">​</a></h2><p>이번 장에서는 예외를 사용할 때의 문제점 몇 가지를 지적하고 순수 함수적 오류 처리의 기본 원리를 소개했다. 예외를 보통의 값으로 표현하고 고차 함수를 이용해서 오류처리 및 전파의 공통 패턴들을 캡슐화한다는 것이다. 이를 더욱 일반화하면 임의의 효과를 값으로 표현한다는 착안이 된다.</p><p>이번에 소개한 도구들이 있으면, 예외는 정말로 복구 불가능한 조건에서만 사용하면 된다.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/kooku0/kooku0.github.io/edit/main/docs/books/functional-programming-in-scala/04.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>페이지 편집</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="문서 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/books/functional-programming-in-scala/introduction/"><div class="pagination-nav__sublabel">이전</div><div class="pagination-nav__label">책 소개</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/books/effective-typescript/introduction/"><div class="pagination-nav__sublabel">다음</div><div class="pagination-nav__label">책 소개</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#41-예외의-장단점" class="table-of-contents__link toc-highlight">4.1 예외의 장단점</a></li><li><a href="#42-예외의-가능한-대안들" class="table-of-contents__link toc-highlight">4.2 예외의 가능한 대안들</a></li><li><a href="#43-option-자료-형식" class="table-of-contents__link toc-highlight">4.3 Option 자료 형식</a><ul><li><a href="#431-option의-사용-패턴" class="table-of-contents__link toc-highlight">4.3.1 Option의 사용 패턴</a></li><li><a href="#432-예외-지향적-api의-option-합성과-승급-감싸기" class="table-of-contents__link toc-highlight">4.3.2 예외 지향적 API의 Option 합성과 승급, 감싸기</a></li></ul></li><li><a href="#44-either-자료-형식" class="table-of-contents__link toc-highlight">4.4 Either 자료 형식</a></li><li><a href="#45-요약" class="table-of-contents__link toc-highlight">4.5 요약</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog/">블로그</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/books/">책</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/kooku0/kooku0.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.linkedin.com/in/mingyu-gu-25aa761b5/" target="_blank" rel="noopener noreferrer" class="footer__link-item">LinkedIn<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 kooku's log, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.879624a5.js"></script>
<script src="/assets/js/main.c4a10850.js"></script>
</body>
</html>