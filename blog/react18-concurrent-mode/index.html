<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-blog" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.0">
<title data-rh="true">React v18 Concurrent mode | Kooku&#x27;s log</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://kooku0.github.io/blog/react18-concurrent-mode/"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="React v18 Concurrent mode | Kooku&#x27;s log"><meta data-rh="true" name="description" content="아직 React 18이 정식 릴리즈되지 않았지만 React 18 Plan을 통해 어떤 기능들이 추가되는지 대부분 알고 있을 것이라고 생각됩니다. 아마 실제로 사용하고 있는 팀들도 있을 것 같네요."><meta data-rh="true" property="og:description" content="아직 React 18이 정식 릴리즈되지 않았지만 React 18 Plan을 통해 어떤 기능들이 추가되는지 대부분 알고 있을 것이라고 생각됩니다. 아마 실제로 사용하고 있는 팀들도 있을 것 같네요."><meta data-rh="true" name="keywords" content="react 18,react,concurrent mode"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-03-17T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="react"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://kooku0.github.io/blog/react18-concurrent-mode/"><link data-rh="true" rel="alternate" href="https://kooku0.github.io/blog/react18-concurrent-mode/" hreflang="ko"><link data-rh="true" rel="alternate" href="https://kooku0.github.io/blog/react18-concurrent-mode/" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://kooku0.github.io/blog/react18-concurrent-mode","mainEntityOfPage":"https://kooku0.github.io/blog/react18-concurrent-mode","url":"https://kooku0.github.io/blog/react18-concurrent-mode","headline":"React v18 Concurrent mode","name":"React v18 Concurrent mode","description":"아직 React 18이 정식 릴리즈되지 않았지만 React 18 Plan을 통해 어떤 기능들이 추가되는지 대부분 알고 있을 것이라고 생각됩니다. 아마 실제로 사용하고 있는 팀들도 있을 것 같네요.","datePublished":"2022-03-17T00:00:00.000Z","author":[],"keywords":["react 18","react","concurrent mode"],"isPartOf":{"@type":"Blog","@id":"https://kooku0.github.io/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kooku&#39;s log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kooku&#39;s log Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KVSM4B0KPY"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-KVSM4B0KPY",{})</script>



<link rel="alternate" type="application/rss+xml" href="/retrospect/rss.xml" title="Kooku&#39;s log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/retrospect/atom.xml" title="Kooku&#39;s log Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/journal/rss.xml" title="Kooku&#39;s log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/journal/atom.xml" title="Kooku&#39;s log Atom Feed"><link rel="stylesheet" href="/assets/css/styles.fee6da73.css">
<script src="/assets/js/runtime~main.029eb6d8.js" defer="defer"></script>
<script src="/assets/js/main.0388bff9.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="dark";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/favicon.ico"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_NOcl" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="사이드바 펼치거나 접기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.ico" alt="My Site Logo" class="themedComponent_ZEmY themedComponent--light_FtRR"><img src="/img/favicon.ico" alt="My Site Logo" class="themedComponent_ZEmY themedComponent--dark_Mxjv"></div><b class="navbar__title text--truncate">Kooku&#x27;s log</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog/">Blog</a><a class="navbar__item navbar__link" href="/docs/books/">Book</a><a class="navbar__item navbar__link" href="/journal/">Journal</a><a class="navbar__item navbar__link" href="/docs/smartfarm/">Smartfarm</a><a class="navbar__item navbar__link" href="/docs/stock/financial-statements/">Stock</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/kooku0/kooku0.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_Mwx1"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_jase colorModeToggle_lYe3"><button class="clean-btn toggleButton_m9xI toggleButtonDisabled_SFpV" type="button" disabled="" title="system mode" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_oaMR lightToggleIcon_mm09"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_oaMR darkToggleIcon_WIli"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_oaMR systemToggleIcon_W5A2"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Jfr1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_zdZd"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_Lba_ thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_KLSk margin-bottom--md">모든 게시물</div><div role="group"><h3 class="yearGroupHeading_Ehxc">2022</h3><ul class="sidebarItemList_ik0y clean-list"><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/프론트엔드에-solid-적용하기/">프론트엔드에 SOLID 적용하기</a></li><li class="sidebarItem_UXcq"><a aria-current="page" class="sidebarItemLink_zIbr sidebarItemLinkActive_EtLp" href="/blog/react18-concurrent-mode/">React v18 Concurrent mode</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/auto로-버전관리와-배포관리하기/">auto로 버전관리와 배포관리하기</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/외부-라이브러리-테스트코드-짜기/">외부 라이브러리 테스트코드 짜기</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/컴포넌트를-어떻게-만들어야할까/">컴포넌트를 어떻게 만들어야 할까?</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_Ehxc">2021</h3><ul class="sidebarItemList_ik0y clean-list"><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/프론트엔드에서-테스트코드 짜기/">프론트엔드에서 테스트코드 짜기</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/컴포넌트-응집도/">컴포넌트 응집도</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/react에서-side-effect를-관리하는-법/">React에서 side effect를 관리하는 법</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/마이크로서비스-아키텍처를-모노레포로-관리하기/">마이크로서비스 아키텍처를 모노레포로 관리하기</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/재사용-가능한-컴포넌트/">재사용 가능한 컴포넌트</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/http-caching/">HTTP Caching</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/react가-class-component에서-functional-component로-패러다임을-전환한-이유/">React가 Class Component에서 Functional Component로 패러다임을 전환한 이유</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/data-fetching-library-어떻게-사용해야할까/">Data Fetching Library 어떻게 사용해야할까?</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/next-image-에-대해/">next/image 에 대해</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/web-vitals/">Web Vitals</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/height-performace-animations/">Height Performace Animations</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/execution-context/">Execution Context</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/throttling-debouncing/">Throttling &amp; Debouncing</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/use-webp-images/">Use WebP images</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/react-v17/">React v17</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/domcontentloaded-vs-onload/">DOMContentLoaded vs onLoad</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/render-blocking-css/">Render-Blocking CSS</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/resource-priority/">Resource Priority</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/react-fiber/">React fiber &amp; reconciliation</a></li><li class="sidebarItem_UXcq"><a class="sidebarItemLink_zIbr" href="/blog/third-party-javascript-performance-with-script-async-defer/">Third-party JavaScript performance</a></li></ul></div></nav></aside><main class="col col--7"><article class=""><header><h1 class="title_GF8P">React v18 Concurrent mode</h1><div class="container_s0Se margin-vert--md"><time datetime="2022-03-17T00:00:00.000Z">2022년 3월 17일</time> · <!-- -->약 5분</div></header><div id="__blog-post-container" class="markdown"><p>아직 React 18이 정식 릴리즈되지 않았지만 <a href="https://ko.reactjs.org/blog/2021/06/08/the-plan-for-react-18.html" target="_blank" rel="noopener noreferrer">React 18 Plan</a>을 통해 어떤 기능들이 추가되는지 대부분 알고 있을 것이라고 생각됩니다. 아마 실제로 사용하고 있는 팀들도 있을 것 같네요.</p>
<p>react-18-plan 블로그의 첫 문단을 읽어보면 react 18에서 어떤 부분을 강조하고 있는지 나옵니다.</p>
<blockquote>
<p>When it’s released, React 18 will include out-of-the-box improvements (like automatic batching), new APIs (like startTransition), and a new streaming server renderer with built-in support for React.lazy.</p>
<p>이러한 기능들이 가능한건 &quot;concurrent rendering&quot;이라고 부르는 opt-in 매커니즘이 React 18에 추가되었기 때문이다. 이것은 React가 동시에 여러 버전의 UI를 준비할 수 있게합니다. 이러한 변화는 인지 범위 밖에 있지만 실제 성능과 인지 성능을 모두 개선할 수 있는 새로운 가능성을 열어줍니다.</p>
</blockquote>
<p>글에서 &quot;concurrent rendering&quot;을 강조하고 있듯이 이번 v18의 핵심주제는 concurrent rendering입니다.</p>
<p>React v16.3에 나온 Fiber도 그렇고 이번 v18에 올라온 Concurrent mode에도 그렇듯이 UX을 매우 중시하여 지속적으로 개선시키는 노력을 하고 있습니다. 그리고 그러한 노력에는 update-rendering을 할때 발생하는 recoiliation의 시간이 오래걸리면 UX를 해치는데 이를 어떻게 최적화할 수 있을까? 라는 문제해결이 바탕이 된 것 같습니다.</p>
<p>React Fiber의 경우 Reconciliation에서 시간이 오래걸릴 경우 main-thread를 계속 점유하고 있으니 RequestAnimationFrame Queue에 쌓여 있는 작업들이 화면주사율에 따라 제대로 실행되지않아 버벅이는 문제를 해결하고자 나왔습니다.</p>
<p>이번 Concurrent mode의 경우 RequestAnimationFrame에서 확장하여 다른 유저 이벤트들도 제대로 보여주지 않는 문제들을 해결하려고 했습니다. 예를 들자면 렌더링이 진행중일 때 유저가 input창에 key를 입력해도 입력한 key가 보이지 않는경우 (Blocking rendering의 문제)가 있습니다.</p>
<p>React 팀의 지속적인 관심과 노력으로 위의 문제점들을 해결하려고 했던 것 같고 이번 v18에 concurrent mode를 적용함으로써 도입되는 매우 유용한 기능들도 있습니다.</p>
<p>다음으로 공식문서에 올라왔던 Concurrent 모드 소개 페이지를 읽기 쉽게 제가 조금 가다듬어 보았습니다. 아직 읽어보지 않으셨다면 읽어보시면 좋을 것 같습니다.</p>
<div class="theme-admonition theme-admonition-caution admonition_Djjz alert alert--warning"><div class="admonitionHeading_ImtD"><span class="admonitionIcon_WekS"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>주의</div><div class="admonitionContent_AQtx"><p><a href="https://ko.reactjs.org/docs/concurrent-mode-intro.html" target="_blank" rel="noopener noreferrer">Concurrent 모드 소개(실험 단계)</a> 포스팅을 참고하여 작성했습니다.</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_tzX7" id="blocking-vs-interruptible-rendering">Blocking vs Interruptible Rendering<a href="#blocking-vs-interruptible-rendering" class="hash-link" aria-label="Blocking vs Interruptible Rendering에 대한 직접 링크" title="Blocking vs Interruptible Rendering에 대한 직접 링크">​</a></h2>
<p>React를 포함한 UI 라이브러리들은 화면의 렌더링(create or update)을 시작하면 다른 일을 수행할 수 없습니다. 이러한 것을 &quot;blocking rendering&quot;이라고 합니다.</p>
<p>Concurrent 모드에서는, 렌더링이 차단되지 않고 인터럽트가 가능해집니다. 이는 UX를 개선하며 이전에 사용할 수 없었던 기능들을 사용할 수 있도록 만들어줍니다.</p>
<h3 class="anchor anchorWithStickyNavbar_tzX7" id="interruptible-rendering">Interruptible Rendering<a href="#interruptible-rendering" class="hash-link" aria-label="Interruptible Rendering에 대한 직접 링크" title="Interruptible Rendering에 대한 직접 링크">​</a></h3>
<p>필터링 가능한 제품 목록 페이지를 생각해세요. 필터에 입력을 할 때마다 버벅거림을 느낀 적이 있나요? 제품 목록을 업데이트하는 몇몇 작업에서 이는 불가피할 수 있습니다. 그러면 어떻게 이런 문제를 해결할 수 있을까요?</p>
<p>버벅거림을 해결하는 한 가지 방법은 입력을 Debouncing 하는 것입니다. Debouncing하면, 사용자가 타이핑을 멈춰야만 목록을 업데이트합니다. 하지만, 타이핑하고 있을 때 UI가 업데이트하지 않는 사실이 실망스러울 수 있습니다. 이에 대한 대안으로, 입력을 throutle하여 목록을 최대 빈도수로 업데이트 할 수 있습니다.(예를들어 200ms 마다) 그러나 저전력 장치에서는 여전히 버벅거릴 것입니다. Debouncing &amp; Throutling 모두 최적이 아닌 UX를 가져다줍니다.</p>
<p>버벅거리는 이유는 간단합니다. 렌더링이 시작되면 중간에 다른 작업이 끼어들 수 없기 때문입니다. 그래서 렌더링이 진행중인 경우 텍스트 입력의 키를 눌러도 입력된 키가 input창에 바로 보이지 않습니다. 이런 blocking rendering을 사용하고 컴포넌트의 일정량 작업을 하면 항상 버벅임이 발생할 것 입니다.</p>
<p><strong>Concurrent 모드는 렌더링을 인터럽트 가능하도록 만듦으로써 근본적인 문제를 수정합니다.</strong> 이러한 사실은 사용자가 다른 키를 누를 때, React는 브라우저에 텍스트 입력을 업데이트하는 것을 차단할 필요가 없음을 의미합니다. 대신 React는 브라우저가 입력에 대한 업데이트를 paint하고 메모리 내에 있는 업데이트 목록을 계속 렌더링할 수 있도록 합니다. 렌더링이 끝나면 React는 DOM을 업데이트하고 변경 사항들을 화면에 반영합니다.</p>
<p>개념상으로, React가 &quot;브랜치에서&quot; 모든 업데이트를 준비하는 것으로 생각할 수 있습니다. Concurrent모드에서 React는 더 중요한 일을 위해 진행 중인 업데이트를 중단할 수 있고 그리고서 이전 작업으로 돌아갈 수도 있습니다.</p>
<p>Concurrent모드 기술은 UI에서 디바운싱과 스로틀링의 필요성을 줄입니다. 렌더링은 중단이 가능하기 때문에 버벅거림을 피하고자 일부러 작업을 지연시킬 필요가 없습니다.</p>
<h3 class="anchor anchorWithStickyNavbar_tzX7" id="의도적인-로딩-시퀀스">의도적인 로딩 시퀀스<a href="#의도적인-로딩-시퀀스" class="hash-link" aria-label="의도적인 로딩 시퀀스에 대한 직접 링크" title="의도적인 로딩 시퀀스에 대한 직접 링크">​</a></h3>
<p>앱에서 두 화면 사이를 탐색한다고 가정하겠습니다. 경우에 따라서, 새 화면에서 사용자에게 &quot;충분히 좋은&quot; 로딩 state를 보여주기 위해 필요한 코드와 데이터를 불러오지 못 할 수 있습니다. 빈 화면이나 큰 스피너로 전환하는 것은 어려운 일이 될 수 있지만 일반적으로 필요한 코드와 데이터를 가져오는 데에 그렇게 많은 시간이 소요되지않습니다. <strong>React가 기존 화면에서 조금 더 오래 유지할 수 있고 새 화면을 보여주기 전에 &quot;안좋은&quot; 로딩 state를 &quot;건너띌 수&quot; 있다면 더 좋지 않을까요?</strong></p>
<p>Concurrent 모드에서는 이 기능이 내장되어 있습니다. React는 먼저 메모리에서 새로운 화면을 준비하기 시작합니다. 그래서 React는 더 많은 콘텐츠를 불러올 수 있도록 DOM을 업데이트하기 전에 기다릴 수 있습니다. (즉 새로운 화면을 준비하기 전까지 이전 화면을 계속 표시합니다.)</p>
<h3 class="anchor anchorWithStickyNavbar_tzX7" id="동시성">동시성<a href="#동시성" class="hash-link" aria-label="동시성에 대한 직접 링크" title="동시성에 대한 직접 링크">​</a></h3>
<p><strong>Concurrent모드에서 React는 여러 작업을 동시에, 다른 팀원들이 각자 작업할 수 있는 브랜치처럼, 진행할 수 있습니다.</strong></p>
<ul>
<li>CPU 바운드 업데이트의 경우 Concurrency는 더욱 긴급한 업데이트가 이미 시작한 렌더링을 &quot;중단&quot; 할 수 있습니다.</li>
<li>IO 바운드 업데이트(예를 들어 네트워크에서 코드나 데이터를 가져오는 것)의 경우 Concurrency는 모든 데이터가 도달하기 전에 React가 메모리에서 렌더링을 시작할 수 있으며 빈 로딩 state표시를 무시할 수 있음을 의미합니다.</li>
</ul>
<p>React는 휴리스틱을 사용하여 업데이트의 &quot;급함&quot; 정도를 결정하고 몇 줄의 코드를 수정해서 사용자가 모든 상호작용에 대해 원하는 사용자의 경험을 얻을 수 있도록 합니다.</p>
<h3 class="anchor anchorWithStickyNavbar_tzX7" id="생산에-연구를-투입">생산에 연구를 투입<a href="#생산에-연구를-투입" class="hash-link" aria-label="생산에 연구를 투입에 대한 직접 링크" title="생산에 연구를 투입에 대한 직접 링크">​</a></h3>
<p>Concurrent모드 내부적으로 사용하는 다른 &quot;우선순위&quot;는 사람들의 인식에 대한 조사에서의 상호 작용에 대한 부분과 대략적으로 일치합니다.</p>
<p>Concurrent 모드를 통한 목적은 UI 조사 결과를 추상화시키고 그것을 사용할 관용적인 방법을 제공하는 것입니다.</p></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>태그:</b><ul class="tags_MmYn padding--none margin-left--sm"><li class="tag_yIGw"><a rel="tag" class="tag_yx3M tagRegular_c22P" href="/blog/tags/react/">react</a></li></ul></div></div><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><a href="https://github.com/kooku0/kooku0.github.io/edit/main/blog/react18-concurrent-mode.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Wq7p" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>페이지 편집</a></div><div class="col lastUpdated_BRsH"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="블로그 게시물 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/프론트엔드에-solid-적용하기/"><div class="pagination-nav__sublabel">이전 게시물</div><div class="pagination-nav__label">프론트엔드에 SOLID 적용하기</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/auto로-버전관리와-배포관리하기/"><div class="pagination-nav__sublabel">다음 게시물</div><div class="pagination-nav__label">auto로 버전관리와 배포관리하기</div></a></nav></main><div class="col col--2"><div class="tableOfContents_C7Qc thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#blocking-vs-interruptible-rendering" class="table-of-contents__link toc-highlight">Blocking vs Interruptible Rendering</a><ul><li><a href="#interruptible-rendering" class="table-of-contents__link toc-highlight">Interruptible Rendering</a></li><li><a href="#의도적인-로딩-시퀀스" class="table-of-contents__link toc-highlight">의도적인 로딩 시퀀스</a></li><li><a href="#동시성" class="table-of-contents__link toc-highlight">동시성</a></li><li><a href="#생산에-연구를-투입" class="table-of-contents__link toc-highlight">생산에 연구를 투입</a></li></ul></li></ul></div></div></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog/">블로그</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/books/">책</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/kooku0/kooku0.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_Mwx1"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://www.linkedin.com/in/mingyu-gu-25aa761b5/" target="_blank" rel="noopener noreferrer" class="footer__link-item">LinkedIn<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_Mwx1"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 kooku's log, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>